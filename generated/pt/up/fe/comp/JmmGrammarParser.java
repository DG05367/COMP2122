/* Generated by: JavaCC 21 Parser Generator. JmmGrammarParser.java */
package pt.up.fe.comp;

import java.util.Arrays;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.Map;
import java.util.concurrent.CancellationException;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.charset.Charset;
import static pt.up.fe.comp.JmmGrammarConstants.TokenType.*;
@SuppressWarnings("unused")
public class JmmGrammarParser implements JmmGrammarConstants {
    static final int UNLIMITED= Integer.MAX_VALUE;
    // The last token successfully "consumed"
    Token lastConsumedToken;
    private TokenType nextTokenType;
    private Token currentLookaheadToken;
    private int remainingLookahead;
    private boolean scanToEnd, hitFailure, lastLookaheadSucceeded;
    private String currentlyParsedProduction, currentLookaheadProduction;
    private int lookaheadRoutineNesting;
    private boolean cancelled;
    public void cancel() {
        cancelled= true;
    }

    public boolean isCancelled() {
        return cancelled;
    }

    /** Generated Lexer. */
    public JmmGrammarLexer token_source;
    public void setInputSource(String inputSource) {
        token_source.setInputSource(inputSource);
    }

    String getInputSource() {
        return token_source.getInputSource();
    }

    //=================================
    // Generated constructors
    //=================================
    public JmmGrammarParser(String inputSource, CharSequence content) {
        this(new JmmGrammarLexer(inputSource, content));
    }

    public JmmGrammarParser(CharSequence content) {
        this("input", content);
    }

    /**
   * @param inputSource just the name of the input source (typically the filename) that 
   * will be used in error messages and so on.
   * @param path The location (typically the filename) from which to get the input to parse
   */
    public JmmGrammarParser(String inputSource, Path path) throws IOException {
        this(inputSource, JmmGrammarConstants.stringFromBytes(Files.readAllBytes(path)));
    }

    public JmmGrammarParser(String inputSource, Path path, Charset charset) throws IOException {
        this(inputSource, JmmGrammarConstants.stringFromBytes(Files.readAllBytes(path), charset));
    }

    /**
   * @param path The location (typically the filename) from which to get the input to parse
   */
    public JmmGrammarParser(Path path) throws IOException {
        this(path.toString(), path);
    }

    /**
   * @Deprecated Use the constructor that takes a #java.nio.files.Path or just 
   * a String (i.e. CharSequence) directly.
   */
    public JmmGrammarParser(java.io.InputStream stream) {
        this(new InputStreamReader(stream));
    }

    /**
   * @Deprecated Use the constructor that takes a #java.nio.files.Path or just 
   * a String (i.e. CharSequence) directly.
   */
    public JmmGrammarParser(Reader reader) {
        this(new JmmGrammarLexer("input", reader));
    }

    /** Constructor with user supplied Lexer. */
    public JmmGrammarParser(JmmGrammarLexer lexer) {
        token_source= lexer;
        lastConsumedToken= lexer.DUMMY_START_TOKEN;
        lastConsumedToken.setTokenSource(lexer);
    }

    // If the next token is cached, it returns that
    // Otherwise, it goes to the token_source, i.e. the Lexer.
    final private Token nextToken(final Token tok) {
        Token result= token_source.getNextToken(tok);
        while (result.isUnparsed()) {
            result= token_source.getNextToken(result);
        }
        nextTokenType= null;
        return result;
    }

    /**
   * @return the next Token off the stream. This is the same as #getToken(1)
   */
    final public Token getNextToken() {
        return getToken(1);
    }

    /**
 * @param index how many tokens to look ahead
 * @return the specific regular (i.e. parsed) Token index ahead/behind in the stream. 
 * If we are in a lookahead, it looks ahead from the currentLookaheadToken
 * Otherwise, it is the lastConsumedToken. If you pass in a negative
 * number it goes backward.
 */
    final public Token getToken(final int index) {
        Token t= currentLookaheadToken== null?lastConsumedToken:
        currentLookaheadToken;
        for (int i= 0; i<index; i++) {
            t= nextToken(t);
        }
        for (int i= 0; i> index; i--) {
            t= t.getPrevious();
            if (t== null) break;
        }
        return t;
    }

    private final TokenType nextTokenType() {
        if (nextTokenType== null) {
            nextTokenType= nextToken(lastConsumedToken).getType();
        }
        return nextTokenType;
    }

    boolean activateTokenTypes(TokenType...types) {
        boolean result= false;
        for (TokenType tt : types) {
            result|=token_source.activeTokenTypes.add(tt);
        }
        token_source.reset(getToken(0));
        nextTokenType= null;
        return result;
    }

    boolean deactivateTokenTypes(TokenType...types) {
        boolean result= false;
        for (TokenType tt : types) {
            result|=token_source.activeTokenTypes.remove(tt);
        }
        token_source.reset(getToken(0));
        nextTokenType= null;
        return result;
    }

    private static HashMap<TokenType[], EnumSet<TokenType> > enumSetCache= new HashMap<> ();
    private static EnumSet<TokenType> tokenTypeSet(TokenType first, TokenType...rest) {
        TokenType[] key= new TokenType[1+rest.length];
        key[0]= first;
        if (rest.length> 0) {
            System.arraycopy(rest, 0, key, 1, rest.length);
        }
        Arrays.sort(key);
        if (enumSetCache.containsKey(key)) {
            return enumSetCache.get(key);
        }
        EnumSet<TokenType> result= (rest.length== 0)?EnumSet.of(first):
        EnumSet.of(first, rest);
        enumSetCache.put(key, result);
        return result;
    }

    // JmmGrammar.jj:54:1
    final public BaseNode Start() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Start";
        Start Start1= null;
        if (buildTree) {
            Start1= new Start();
            openNodeScope(Start1);
        }
        ParseException parseException1= null;
        int callStackSize2= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for ZeroOrMore specified at:
            // JmmGrammar.jj:55:9
            while (true) {
                if (!(nextTokenType()== IMPORT)) break;
                // Code for NonTerminal specified at:
                // JmmGrammar.jj:55:10
                pushOntoCallStack("Start", "JmmGrammar.jj", 1487);
                try {
                    ImportDeclaration();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:55:30
            pushOntoCallStack("Start", "JmmGrammar.jj", 1507);
            try {
                ClassDeclaration();
            }
            finally {
                popCallStack();
            }
            // Code for EndOfFile specified at:
            // JmmGrammar.jj:55:47
            consumeToken(EOF);
            // Code for CodeBlock specified at:
            // JmmGrammar.jj:55:54
            return Start1;
        }
        catch(ParseException e) {
            parseException1= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2);
            if (Start1!=null) {
                if (parseException1== null) {
                    closeNodeScope(Start1, true);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // JmmGrammar.jj:58:1
    final public void ImportDeclaration() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "ImportDeclaration";
        ImportDeclaration ImportDeclaration2= null;
        if (buildTree) {
            ImportDeclaration2= new ImportDeclaration();
            openNodeScope(ImportDeclaration2);
        }
        ParseException parseException22= null;
        int callStackSize23= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:59:9
            consumeToken(IMPORT);
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:59:18
            consumeToken(IDENTIFIER);
            // Code for CodeBlock specified at:
            // JmmGrammar.jj:59:31
            ImportDeclaration2.put("value", lastConsumedToken.getImage());
            // Code for ZeroOrOne specified at:
            // JmmGrammar.jj:60:9
            if (nextTokenType()== DOT) {
                // Code for NonTerminal specified at:
                // JmmGrammar.jj:61:17
                pushOntoCallStack("ImportDeclaration", "JmmGrammar.jj", 1699);
                try {
                    ExtraImport();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:63:9
            consumeToken(NEXTLINE);
        }
        catch(ParseException e) {
            parseException22= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize23);
            if (ImportDeclaration2!=null) {
                if (parseException22== null) {
                    closeNodeScope(ImportDeclaration2, true);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // JmmGrammar.jj:66:1
    final public void ExtraImport() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "ExtraImport";
        ExtraImport ExtraImport3= null;
        if (buildTree) {
            ExtraImport3= new ExtraImport();
            openNodeScope(ExtraImport3);
        }
        ParseException parseException46= null;
        int callStackSize47= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:67:9
            consumeToken(DOT);
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:67:15
            consumeToken(IDENTIFIER);
            // Code for CodeBlock specified at:
            // JmmGrammar.jj:67:28
            ExtraImport3.put("value", lastConsumedToken.getImage());
            // Code for ZeroOrOne specified at:
            // JmmGrammar.jj:67:84
            if (nextTokenType()== DOT) {
                // Code for NonTerminal specified at:
                // JmmGrammar.jj:67:86
                pushOntoCallStack("ExtraImport", "JmmGrammar.jj", 1849);
                try {
                    ExtraImport();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException46= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize47);
            if (ExtraImport3!=null) {
                if (parseException46== null) {
                    closeNodeScope(ExtraImport3, true);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // JmmGrammar.jj:70:1
    final public void ClassDeclaration() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "ClassDeclaration";
        ClassDeclaration ClassDeclaration4= null;
        if (buildTree) {
            ClassDeclaration4= new ClassDeclaration();
            openNodeScope(ClassDeclaration4);
        }
        BaseNode n;
        ParseException parseException67= null;
        int callStackSize68= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:71:9
            consumeToken(CLASS);
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:71:17
            consumeToken(IDENTIFIER);
            // Code for CodeBlock specified at:
            // JmmGrammar.jj:71:30
            ClassDeclaration4.put("name", lastConsumedToken.getImage());
            n= ClassDeclaration4;
            // Code for ZeroOrOne specified at:
            // JmmGrammar.jj:71:98
            if (nextTokenType()== EXTENDS) {
                // Code for RegexpRef specified at:
                // JmmGrammar.jj:72:17
                consumeToken(EXTENDS);
                // Code for RegexpRef specified at:
                // JmmGrammar.jj:72:27
                consumeToken(IDENTIFIER);
                // Code for CodeBlock specified at:
                // JmmGrammar.jj:72:40
                n.put("extends", lastConsumedToken.getImage());
            }
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:74:9
            consumeToken(OPEN_CHAV);
            // Code for ZeroOrMore specified at:
            // JmmGrammar.jj:74:20
            while (true) {
                if (!(first_set$JmmGrammar_jj$75$17.contains(nextTokenType()))) break;
                // Code for NonTerminal specified at:
                // JmmGrammar.jj:75:17
                pushOntoCallStack("ClassDeclaration", "JmmGrammar.jj", 2143);
                try {
                    VarDeclaration();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for ZeroOrMore specified at:
            // JmmGrammar.jj:77:9
            while (true) {
                if (!(nextTokenType()== PUBLIC)) break;
                // Code for NonTerminal specified at:
                // JmmGrammar.jj:78:17
                pushOntoCallStack("ClassDeclaration", "JmmGrammar.jj", 2195);
                try {
                    MethodDeclaration();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:80:9
            consumeToken(CLOSE_CHAV);
        }
        catch(ParseException e) {
            parseException67= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize68);
            if (ClassDeclaration4!=null) {
                if (parseException67== null) {
                    closeNodeScope(ClassDeclaration4, true);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // JmmGrammar.jj:83:1
    final public void VarDeclaration() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "VarDeclaration";
        VarDeclaration VarDeclaration5= null;
        if (buildTree) {
            VarDeclaration5= new VarDeclaration();
            openNodeScope(VarDeclaration5);
        }
        String type;
        ParseException parseException118= null;
        int callStackSize119= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:84:9
            pushOntoCallStack("VarDeclaration", "JmmGrammar.jj", 2293);
            try {
                type= Type();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:84:19
            consumeToken(IDENTIFIER);
            // Code for CodeBlock specified at:
            // JmmGrammar.jj:84:32
            VarDeclaration5.put("type", type);
            VarDeclaration5.put("id", lastConsumedToken.getImage());
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:84:112
            consumeToken(NEXTLINE);
        }
        catch(ParseException e) {
            parseException118= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize119);
            if (VarDeclaration5!=null) {
                if (parseException118== null) {
                    closeNodeScope(VarDeclaration5, true);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // JmmGrammar.jj:87:1
    final public void MethodDeclaration() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "MethodDeclaration";
        // Code for RegexpRef specified at:
        // JmmGrammar.jj:88:9
        consumeToken(PUBLIC);
        // Code for NonTerminal specified at:
        // JmmGrammar.jj:88:18
        pushOntoCallStack("MethodDeclaration", "JmmGrammar.jj", 2458);
        try {
            MethodExtra();
        }
        finally {
            popCallStack();
        }
    }

    // JmmGrammar.jj:91:1
    final public void Param() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Param";
        Param Param6= null;
        if (buildTree) {
            Param6= new Param();
            openNodeScope(Param6);
        }
        String type;
        ParseException parseException142= null;
        int callStackSize143= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:92:9
            pushOntoCallStack("Param", "JmmGrammar.jj", 2509);
            try {
                type= Type();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:92:19
            consumeToken(IDENTIFIER);
            // Code for CodeBlock specified at:
            // JmmGrammar.jj:92:32
            Param6.put("value", lastConsumedToken.getImage());
            Param6.put("type", type);
        }
        catch(ParseException e) {
            parseException142= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize143);
            if (Param6!=null) {
                if (parseException142== null) {
                    closeNodeScope(Param6, true);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // JmmGrammar.jj:95:1
    final public void Return() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Return";
        Return Return7= null;
        if (buildTree) {
            Return7= new Return();
            openNodeScope(Return7);
        }
        ParseException parseException154= null;
        int callStackSize155= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:96:9
            consumeToken(RETORNO);
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:96:19
            pushOntoCallStack("Return", "JmmGrammar.jj", 2650);
            try {
                Expr();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:96:24
            consumeToken(NEXTLINE);
        }
        catch(ParseException e) {
            parseException154= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize155);
            if (Return7!=null) {
                if (parseException154== null) {
                    closeNodeScope(Return7, true);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> MethodExtra_FIRST_SET= tokenTypeSet(INT, BOOL, STRING, VOID, STATIC, IDENTIFIER);
    // JmmGrammar.jj:99:1
    final public void MethodExtra() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "MethodExtra";
        // Code for ExpansionChoice specified at:
        // JmmGrammar.jj:100:9
        if (first_set$JmmGrammar_jj$100$9.contains(nextTokenType())) {
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:100:9
            pushOntoCallStack("MethodExtra", "JmmGrammar.jj", 2703);
            try {
                ClassMethod();
            }
            finally {
                popCallStack();
            }
        }
        else if (nextTokenType()== STATIC) {
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:100:23
            pushOntoCallStack("MethodExtra", "JmmGrammar.jj", 2717);
            try {
                MainMethod();
            }
            finally {
                popCallStack();
            }
        }
        else  {
            pushOntoCallStack("MethodExtra", "JmmGrammar.jj", 2703);
            throw new ParseException(this, MethodExtra_FIRST_SET, parsingStack);
        }
    }

    // JmmGrammar.jj:103:1
    final public void ClassMethod() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "ClassMethod";
        String type;
        ClassMethod ClassMethod8= null;
        if (buildTree) {
            ClassMethod8= new ClassMethod();
            openNodeScope(ClassMethod8);
        }
        ParseException parseException184= null;
        int callStackSize185= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:104:10
            pushOntoCallStack("ClassMethod", "JmmGrammar.jj", 2780);
            try {
                type= Type();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:104:20
            consumeToken(IDENTIFIER);
            // Code for CodeBlock specified at:
            // JmmGrammar.jj:104:33
            ClassMethod8.put("name", lastConsumedToken.getImage());
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:104:88
            consumeToken(OPEN_PAREN);
            // Code for ZeroOrOne specified at:
            // JmmGrammar.jj:104:101
            if (first_set$JmmGrammar_jj$105$17.contains(nextTokenType())) {
                // Code for NonTerminal specified at:
                // JmmGrammar.jj:105:17
                pushOntoCallStack("ClassMethod", "JmmGrammar.jj", 2889);
                try {
                    Param();
                }
                finally {
                    popCallStack();
                }
                // Code for ZeroOrMore specified at:
                // JmmGrammar.jj:105:22
                while (true) {
                    if (!(nextTokenType()== COMMA)) break;
                    // Code for RegexpRef specified at:
                    // JmmGrammar.jj:106:25
                    consumeToken(COMMA);
                    // Code for NonTerminal specified at:
                    // JmmGrammar.jj:106:33
                    pushOntoCallStack("ClassMethod", "JmmGrammar.jj", 2928);
                    try {
                        Param();
                    }
                    finally {
                        popCallStack();
                    }
                }
            }
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:109:9
            consumeToken(CLOSE_PAREN);
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:109:23
            consumeToken(OPEN_CHAV);
            // Code for ZeroOrMore specified at:
            // JmmGrammar.jj:109:34
            while (true) {
                if (!(scan$JmmGrammar_jj$110$17())) break;
                // Code for NonTerminal specified at:
                // JmmGrammar.jj:110:30
                pushOntoCallStack("ClassMethod", "JmmGrammar.jj", 3028);
                try {
                    VarDeclaration();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for ZeroOrMore specified at:
            // JmmGrammar.jj:112:9
            while (true) {
                if (!(first_set$JmmGrammar_jj$113$17.contains(nextTokenType()))) break;
                // Code for NonTerminal specified at:
                // JmmGrammar.jj:113:17
                pushOntoCallStack("ClassMethod", "JmmGrammar.jj", 3080);
                try {
                    Statement();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:115:9
            pushOntoCallStack("ClassMethod", "JmmGrammar.jj", 3109);
            try {
                Return();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:115:16
            consumeToken(CLOSE_CHAV);
            // Code for CodeBlock specified at:
            // JmmGrammar.jj:115:29
            ClassMethod8.put("return", type);
        }
        catch(ParseException e) {
            parseException184= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize185);
            if (ClassMethod8!=null) {
                if (parseException184== null) {
                    closeNodeScope(ClassMethod8, true);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // JmmGrammar.jj:118:1
    final public void MainMethod() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "MainMethod";
        MainMethod MainMethod9= null;
        if (buildTree) {
            MainMethod9= new MainMethod();
            openNodeScope(MainMethod9);
        }
        ParseException parseException257= null;
        int callStackSize258= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:119:10
            consumeToken(STATIC);
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:119:19
            consumeToken(VOID);
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:119:26
            consumeToken(MAIN);
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:119:33
            consumeToken(OPEN_PAREN);
            Param MainMethod10= null;
            if (buildTree) {
                MainMethod10= new Param();
                openNodeScope(MainMethod10);
            }
            ParseException parseException273= null;
            int callStackSize274= parsingStack.size();
            try {
                if (false) throw new ParseException("Never happens!");
                // Code for RegexpRef specified at:
                // JmmGrammar.jj:119:47
                consumeToken(STRING);
                // Code for RegexpRef specified at:
                // JmmGrammar.jj:119:56
                consumeToken(OPEN_RET);
                // Code for RegexpRef specified at:
                // JmmGrammar.jj:119:67
                consumeToken(CLOSE_RET);
                // Code for RegexpRef specified at:
                // JmmGrammar.jj:120:9
                consumeToken(IDENTIFIER);
                // Code for CodeBlock specified at:
                // JmmGrammar.jj:120:22
                MainMethod10.put("value", lastConsumedToken.getImage());
                MainMethod10.put("type", "String");
            }
            catch(ParseException e) {
                parseException273= e;
                throw e;
            }
            finally {
                restoreCallStack(callStackSize274);
                if (MainMethod10!=null) {
                    if (parseException273== null) {
                        closeNodeScope(MainMethod10, true);
                    }
                    else  {
                        clearNodeScope();
                    }
                }
                this.currentlyParsedProduction= prevProduction;
            }
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:120:117
            consumeToken(CLOSE_PAREN);
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:120:131
            consumeToken(OPEN_CHAV);
            // Code for ZeroOrMore specified at:
            // JmmGrammar.jj:120:142
            while (true) {
                if (!(scan$JmmGrammar_jj$121$17())) break;
                // Code for NonTerminal specified at:
                // JmmGrammar.jj:121:30
                pushOntoCallStack("MainMethod", "JmmGrammar.jj", 3453);
                try {
                    VarDeclaration();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for ZeroOrMore specified at:
            // JmmGrammar.jj:123:9
            while (true) {
                if (!(first_set$JmmGrammar_jj$124$17.contains(nextTokenType()))) break;
                // Code for NonTerminal specified at:
                // JmmGrammar.jj:124:17
                pushOntoCallStack("MainMethod", "JmmGrammar.jj", 3505);
                try {
                    Statement();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:126:9
            consumeToken(CLOSE_CHAV);
        }
        catch(ParseException e) {
            parseException257= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize258);
            if (MainMethod9!=null) {
                if (parseException257== null) {
                    closeNodeScope(MainMethod9, true);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> Type_FIRST_SET= tokenTypeSet(INT, BOOL, STRING, VOID, IDENTIFIER);
    // JmmGrammar.jj:129:1
    final public String Type() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Type";
        // Code for ExpansionChoice specified at:
        // JmmGrammar.jj:130:9
        if (scan$JmmGrammar_jj$130$9()) {
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:130:22
            consumeToken(INT);
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:130:28
            consumeToken(OPEN_RET);
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:130:39
            consumeToken(CLOSE_RET);
            // Code for CodeBlock specified at:
            // JmmGrammar.jj:130:51
            return"int[]";
        }
        else if (nextTokenType()== BOOL) {
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:131:9
            consumeToken(BOOL);
            // Code for CodeBlock specified at:
            // JmmGrammar.jj:131:16
            return lastConsumedToken.getImage();
        }
        else if (nextTokenType()== INT) {
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:132:9
            consumeToken(INT);
            // Code for CodeBlock specified at:
            // JmmGrammar.jj:132:15
            return lastConsumedToken.getImage();
        }
        else if (nextTokenType()== STRING) {
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:133:9
            consumeToken(STRING);
            // Code for CodeBlock specified at:
            // JmmGrammar.jj:133:18
            return lastConsumedToken.getImage();
        }
        else if (nextTokenType()== VOID) {
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:134:9
            consumeToken(VOID);
            // Code for CodeBlock specified at:
            // JmmGrammar.jj:134:16
            return lastConsumedToken.getImage();
        }
        else if (nextTokenType()== IDENTIFIER) {
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:135:9
            consumeToken(IDENTIFIER);
            // Code for CodeBlock specified at:
            // JmmGrammar.jj:135:22
            return lastConsumedToken.getImage();
        }
        else  {
            pushOntoCallStack("Type", "JmmGrammar.jj", 3591);
            throw new ParseException(this, Type_FIRST_SET, parsingStack);
        }
    }

    // JmmGrammar.jj:138:1
    final public void IfElse() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "IfElse";
        IfElse IfElse11= null;
        if (buildTree) {
            IfElse11= new IfElse();
            openNodeScope(IfElse11);
        }
        ParseException parseException382= null;
        int callStackSize383= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:139:9
            pushOntoCallStack("IfElse", "JmmGrammar.jj", 3975);
            try {
                IfStmt();
            }
            finally {
                popCallStack();
            }
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:139:16
            pushOntoCallStack("IfElse", "JmmGrammar.jj", 3982);
            try {
                ElseStmt();
            }
            finally {
                popCallStack();
            }
        }
        catch(ParseException e) {
            parseException382= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize383);
            if (IfElse11!=null) {
                if (parseException382== null) {
                    closeNodeScope(IfElse11, true);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // JmmGrammar.jj:142:1
    final public void IfStmt() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "IfStmt";
        IfStmt IfStmt12= null;
        if (buildTree) {
            IfStmt12= new IfStmt();
            openNodeScope(IfStmt12);
        }
        ParseException parseException391= null;
        int callStackSize392= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:143:9
            consumeToken(IF);
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:143:14
            consumeToken(OPEN_PAREN);
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:143:27
            IfCondition IfStmt13= null;
            if (buildTree) {
                IfStmt13= new IfCondition();
                openNodeScope(IfStmt13);
            }
            ParseException parseException400= null;
            int callStackSize401= parsingStack.size();
            try {
                if (false) throw new ParseException("Never happens!");
                pushOntoCallStack("IfStmt", "JmmGrammar.jj", 4034);
                try {
                    Expr();
                }
                finally {
                    popCallStack();
                }
            }
            catch(ParseException e) {
                parseException400= e;
                throw e;
            }
            finally {
                restoreCallStack(callStackSize401);
                if (IfStmt13!=null) {
                    if (parseException400== null) {
                        closeNodeScope(IfStmt13, true);
                    }
                    else  {
                        clearNodeScope();
                    }
                }
                this.currentlyParsedProduction= prevProduction;
            }
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:143:45
            consumeToken(CLOSE_PAREN);
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:143:59
            pushOntoCallStack("IfStmt", "JmmGrammar.jj", 4066);
            try {
                Statement();
            }
            finally {
                popCallStack();
            }
        }
        catch(ParseException e) {
            parseException391= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize392);
            if (IfStmt12!=null) {
                if (parseException391== null) {
                    closeNodeScope(IfStmt12, true);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // JmmGrammar.jj:146:1
    final public void ElseStmt() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "ElseStmt";
        ElseStmt ElseStmt14= null;
        if (buildTree) {
            ElseStmt14= new ElseStmt();
            openNodeScope(ElseStmt14);
        }
        ParseException parseException409= null;
        int callStackSize410= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:147:9
            consumeToken(ELSE);
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:147:16
            pushOntoCallStack("ElseStmt", "JmmGrammar.jj", 4110);
            try {
                Statement();
            }
            finally {
                popCallStack();
            }
        }
        catch(ParseException e) {
            parseException409= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize410);
            if (ElseStmt14!=null) {
                if (parseException409== null) {
                    closeNodeScope(ElseStmt14, true);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // JmmGrammar.jj:150:1
    final public void WhileStmt() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "WhileStmt";
        WhileStmt WhileStmt15= null;
        if (buildTree) {
            WhileStmt15= new WhileStmt();
            openNodeScope(WhileStmt15);
        }
        ParseException parseException418= null;
        int callStackSize419= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:151:9
            consumeToken(WHILE);
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:151:17
            consumeToken(OPEN_PAREN);
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:151:30
            WhileCondition WhileStmt16= null;
            if (buildTree) {
                WhileStmt16= new WhileCondition();
                openNodeScope(WhileStmt16);
            }
            ParseException parseException427= null;
            int callStackSize428= parsingStack.size();
            try {
                if (false) throw new ParseException("Never happens!");
                pushOntoCallStack("WhileStmt", "JmmGrammar.jj", 4169);
                try {
                    Expr();
                }
                finally {
                    popCallStack();
                }
            }
            catch(ParseException e) {
                parseException427= e;
                throw e;
            }
            finally {
                restoreCallStack(callStackSize428);
                if (WhileStmt16!=null) {
                    if (parseException427== null) {
                        closeNodeScope(WhileStmt16, true);
                    }
                    else  {
                        clearNodeScope();
                    }
                }
                this.currentlyParsedProduction= prevProduction;
            }
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:151:51
            consumeToken(CLOSE_PAREN);
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:151:65
            pushOntoCallStack("WhileStmt", "JmmGrammar.jj", 4204);
            try {
                Statement();
            }
            finally {
                popCallStack();
            }
        }
        catch(ParseException e) {
            parseException418= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize419);
            if (WhileStmt15!=null) {
                if (parseException418== null) {
                    closeNodeScope(WhileStmt15, true);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> Statement_FIRST_SET= Statement_FIRST_SET_init();
    static private EnumSet<TokenType> Statement_FIRST_SET_init() {
        return tokenTypeSet(OPEN_PAREN, INTEGER, OPEN_CHAV, IF, WHILE, TRUE, FALSE, THIS, NEW, EXCL, IDENTIFIER);
    }

    // JmmGrammar.jj:154:1
    final public void Statement() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Statement";
        // Code for ExpansionChoice specified at:
        // JmmGrammar.jj:155:9
        if (nextTokenType()== OPEN_CHAV) {
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:155:9
            consumeToken(OPEN_CHAV);
            // Code for ZeroOrMore specified at:
            // JmmGrammar.jj:156:9
            while (true) {
                if (!(first_set$JmmGrammar_jj$157$17.contains(nextTokenType()))) break;
                // Code for NonTerminal specified at:
                // JmmGrammar.jj:157:17
                pushOntoCallStack("Statement", "JmmGrammar.jj", 4286);
                try {
                    Statement();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:159:9
            consumeToken(CLOSE_CHAV);
        }
        else if (nextTokenType()== IF) {
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:161:9
            pushOntoCallStack("Statement", "JmmGrammar.jj", 4346);
            try {
                IfElse();
            }
            finally {
                popCallStack();
            }
        }
        else if (nextTokenType()== WHILE) {
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:162:9
            pushOntoCallStack("Statement", "JmmGrammar.jj", 4363);
            try {
                WhileStmt();
            }
            finally {
                popCallStack();
            }
        }
        else if (scan$JmmGrammar_jj$163$9()) {
            Assignment Statement17= null;
            if (buildTree) {
                Statement17= new Assignment();
                openNodeScope(Statement17);
            }
            ParseException parseException472= null;
            int callStackSize473= parsingStack.size();
            try {
                if (false) throw new ParseException("Never happens!");
                // Code for RegexpRef specified at:
                // JmmGrammar.jj:163:23
                consumeToken(IDENTIFIER);
                // Code for CodeBlock specified at:
                // JmmGrammar.jj:163:36
                Statement17.put("var", lastConsumedToken.getImage());
                // Code for ZeroOrOne specified at:
                // JmmGrammar.jj:163:90
                if (nextTokenType()== OPEN_RET) {
                    ArrayAccess Statement18= null;
                    if (buildTree) {
                        Statement18= new ArrayAccess();
                        openNodeScope(Statement18);
                    }
                    ParseException parseException488= null;
                    int callStackSize489= parsingStack.size();
                    try {
                        if (false) throw new ParseException("Never happens!");
                        // Code for RegexpRef specified at:
                        // JmmGrammar.jj:163:92
                        consumeToken(OPEN_RET);
                        // Code for NonTerminal specified at:
                        // JmmGrammar.jj:163:103
                        pushOntoCallStack("Statement", "JmmGrammar.jj", 4477);
                        try {
                            Expr();
                        }
                        finally {
                            popCallStack();
                        }
                        // Code for RegexpRef specified at:
                        // JmmGrammar.jj:163:108
                        consumeToken(CLOSE_RET);
                    }
                    catch(ParseException e) {
                        parseException488= e;
                        throw e;
                    }
                    finally {
                        restoreCallStack(callStackSize489);
                        if (Statement18!=null) {
                            if (parseException488== null) {
                                closeNodeScope(Statement18, true);
                            }
                            else  {
                                clearNodeScope();
                            }
                        }
                        this.currentlyParsedProduction= prevProduction;
                    }
                }
                // Code for RegexpRef specified at:
                // JmmGrammar.jj:163:136
                consumeToken(EQUAL);
                // Code for NonTerminal specified at:
                // JmmGrammar.jj:163:144
                pushOntoCallStack("Statement", "JmmGrammar.jj", 4518);
                try {
                    Expr();
                }
                finally {
                    popCallStack();
                }
                // Code for RegexpRef specified at:
                // JmmGrammar.jj:163:149
                consumeToken(NEXTLINE);
            }
            catch(ParseException e) {
                parseException472= e;
                throw e;
            }
            finally {
                restoreCallStack(callStackSize473);
                if (Statement17!=null) {
                    if (parseException472== null) {
                        closeNodeScope(Statement17, true);
                    }
                    else  {
                        clearNodeScope();
                    }
                }
                this.currentlyParsedProduction= prevProduction;
            }
        }
        else if (first_set$JmmGrammar_jj$164$9.contains(nextTokenType())) {
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:164:10
            pushOntoCallStack("Statement", "JmmGrammar.jj", 4558);
            try {
                Expr();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:164:15
            consumeToken(NEXTLINE);
        }
        else  {
            pushOntoCallStack("Statement", "JmmGrammar.jj", 4248);
            throw new ParseException(this, Statement_FIRST_SET, parsingStack);
        }
    }

    // JmmGrammar.jj:167:1
    final public void Expr() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Expr";
        // Code for NonTerminal specified at:
        // JmmGrammar.jj:168:9
        pushOntoCallStack("Expr", "JmmGrammar.jj", 4604);
        try {
            RelExpr();
        }
        finally {
            popCallStack();
        }
        // Code for ZeroOrMore specified at:
        // JmmGrammar.jj:168:17
        while (true) {
            if (!(nextTokenType()== AND)) break;
            AndExpression Expr19= null;
            if (buildTree) {
                Expr19= new AndExpression();
                openNodeScope(Expr19);
            }
            ParseException parseException535= null;
            int callStackSize536= parsingStack.size();
            try {
                if (false) throw new ParseException("Never happens!");
                // Code for RegexpRef specified at:
                // JmmGrammar.jj:168:19
                consumeToken(AND);
                // Code for NonTerminal specified at:
                // JmmGrammar.jj:168:25
                pushOntoCallStack("Expr", "JmmGrammar.jj", 4620);
                try {
                    RelExpr();
                }
                finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at:
                // JmmGrammar.jj:168:33
                Expr19.put("op", "and");
            }
            catch(ParseException e) {
                parseException535= e;
                throw e;
            }
            finally {
                restoreCallStack(callStackSize536);
                if (Expr19!=null) {
                    if (parseException535== null) {
                        closeNodeScope(Expr19, 2);
                    }
                    else  {
                        clearNodeScope();
                    }
                }
                this.currentlyParsedProduction= prevProduction;
            }
        }
    }

    // JmmGrammar.jj:171:1
    final public void RelExpr() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "RelExpr";
        // Code for NonTerminal specified at:
        // JmmGrammar.jj:172:9
        pushOntoCallStack("RelExpr", "JmmGrammar.jj", 4711);
        try {
            AddExpr();
        }
        finally {
            popCallStack();
        }
        // Code for ZeroOrMore specified at:
        // JmmGrammar.jj:172:17
        while (true) {
            if (!(nextTokenType()== LESS)) break;
            RelationalExpression RelExpr20= null;
            if (buildTree) {
                RelExpr20= new RelationalExpression();
                openNodeScope(RelExpr20);
            }
            ParseException parseException560= null;
            int callStackSize561= parsingStack.size();
            try {
                if (false) throw new ParseException("Never happens!");
                // Code for RegexpRef specified at:
                // JmmGrammar.jj:172:19
                consumeToken(LESS);
                // Code for NonTerminal specified at:
                // JmmGrammar.jj:172:26
                pushOntoCallStack("RelExpr", "JmmGrammar.jj", 4728);
                try {
                    AddExpr();
                }
                finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at:
                // JmmGrammar.jj:172:34
                RelExpr20.put("op", "<");
            }
            catch(ParseException e) {
                parseException560= e;
                throw e;
            }
            finally {
                restoreCallStack(callStackSize561);
                if (RelExpr20!=null) {
                    if (parseException560== null) {
                        closeNodeScope(RelExpr20, 2);
                    }
                    else  {
                        clearNodeScope();
                    }
                }
                this.currentlyParsedProduction= prevProduction;
            }
        }
    }

    // JmmGrammar.jj:175:1
    final public void AddExpr() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "AddExpr";
        // Code for NonTerminal specified at:
        // JmmGrammar.jj:176:9
        pushOntoCallStack("AddExpr", "JmmGrammar.jj", 4824);
        try {
            MulExpr();
        }
        finally {
            popCallStack();
        }
        // Code for ZeroOrMore specified at:
        // JmmGrammar.jj:176:17
        while (true) {
            if (!(nextTokenType()== PLUS||nextTokenType== MINUS)) break;
            BinOp AddExpr21= null;
            if (buildTree) {
                AddExpr21= new BinOp();
                openNodeScope(AddExpr21);
            }
            ParseException parseException585= null;
            int callStackSize586= parsingStack.size();
            try {
                if (false) throw new ParseException("Never happens!");
                if (nextTokenType()== PLUS) {
                    // Code for RegexpRef specified at:
                    // JmmGrammar.jj:176:20
                    consumeToken(PLUS);
                }
                else if (nextTokenType()== MINUS) {
                    // Code for RegexpRef specified at:
                    // JmmGrammar.jj:176:29
                    consumeToken(MINUS);
                }
                else  {
                    pushOntoCallStack("AddExpr", "JmmGrammar.jj", 4835);
                    throw new ParseException(this, first_set$JmmGrammar_jj$176$20, parsingStack);
                }
                // Code for CodeBlock specified at:
                // JmmGrammar.jj:176:38
                AddExpr21.put("op", lastConsumedToken.getImage());
                // Code for NonTerminal specified at:
                // JmmGrammar.jj:176:91
                pushOntoCallStack("AddExpr", "JmmGrammar.jj", 4906);
                try {
                    MulExpr();
                }
                finally {
                    popCallStack();
                }
            }
            catch(ParseException e) {
                parseException585= e;
                throw e;
            }
            finally {
                restoreCallStack(callStackSize586);
                if (AddExpr21!=null) {
                    if (parseException585== null) {
                        closeNodeScope(AddExpr21, 2);
                    }
                    else  {
                        clearNodeScope();
                    }
                }
                this.currentlyParsedProduction= prevProduction;
            }
        }
    }

    // JmmGrammar.jj:179:1
    final public void MulExpr() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "MulExpr";
        // Code for NonTerminal specified at:
        // JmmGrammar.jj:180:9
        pushOntoCallStack("MulExpr", "JmmGrammar.jj", 4959);
        try {
            NotExpr();
        }
        finally {
            popCallStack();
        }
        // Code for ZeroOrMore specified at:
        // JmmGrammar.jj:180:17
        while (true) {
            if (!(nextTokenType()== TIMES||nextTokenType== DIVIDE)) break;
            BinOp MulExpr22= null;
            if (buildTree) {
                MulExpr22= new BinOp();
                openNodeScope(MulExpr22);
            }
            ParseException parseException623= null;
            int callStackSize624= parsingStack.size();
            try {
                if (false) throw new ParseException("Never happens!");
                if (nextTokenType()== TIMES) {
                    // Code for RegexpRef specified at:
                    // JmmGrammar.jj:180:20
                    consumeToken(TIMES);
                }
                else if (nextTokenType()== DIVIDE) {
                    // Code for RegexpRef specified at:
                    // JmmGrammar.jj:180:30
                    consumeToken(DIVIDE);
                }
                else  {
                    pushOntoCallStack("MulExpr", "JmmGrammar.jj", 4970);
                    throw new ParseException(this, first_set$JmmGrammar_jj$180$20, parsingStack);
                }
                // Code for CodeBlock specified at:
                // JmmGrammar.jj:180:40
                MulExpr22.put("op", lastConsumedToken.getImage());
                // Code for NonTerminal specified at:
                // JmmGrammar.jj:180:93
                pushOntoCallStack("MulExpr", "JmmGrammar.jj", 5043);
                try {
                    NotExpr();
                }
                finally {
                    popCallStack();
                }
            }
            catch(ParseException e) {
                parseException623= e;
                throw e;
            }
            finally {
                restoreCallStack(callStackSize624);
                if (MulExpr22!=null) {
                    if (parseException623== null) {
                        closeNodeScope(MulExpr22, 2);
                    }
                    else  {
                        clearNodeScope();
                    }
                }
                this.currentlyParsedProduction= prevProduction;
            }
        }
    }

    static private final EnumSet<TokenType> NotExpr_FIRST_SET= NotExpr_FIRST_SET_init();
    static private EnumSet<TokenType> NotExpr_FIRST_SET_init() {
        return tokenTypeSet(OPEN_PAREN, INTEGER, TRUE, FALSE, THIS, NEW, EXCL, IDENTIFIER);
    }

    // JmmGrammar.jj:183:1
    final public void NotExpr() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "NotExpr";
        // Code for ExpansionChoice specified at:
        // JmmGrammar.jj:184:9
        if (nextTokenType()== EXCL) {
            NotExpression NotExpr23= null;
            if (buildTree) {
                NotExpr23= new NotExpression();
                openNodeScope(NotExpr23);
            }
            ParseException parseException655= null;
            int callStackSize656= parsingStack.size();
            try {
                if (false) throw new ParseException("Never happens!");
                // Code for RegexpRef specified at:
                // JmmGrammar.jj:184:10
                consumeToken(EXCL);
                // Code for NonTerminal specified at:
                // JmmGrammar.jj:184:17
                pushOntoCallStack("NotExpr", "JmmGrammar.jj", 5104);
                try {
                    NotExpr();
                }
                finally {
                    popCallStack();
                }
            }
            catch(ParseException e) {
                parseException655= e;
                throw e;
            }
            finally {
                restoreCallStack(callStackSize656);
                if (NotExpr23!=null) {
                    if (parseException655== null) {
                        closeNodeScope(NotExpr23, true);
                    }
                    else  {
                        clearNodeScope();
                    }
                }
                this.currentlyParsedProduction= prevProduction;
            }
        }
        else if (first_set$JmmGrammar_jj$184$43.contains(nextTokenType())) {
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:184:43
            pushOntoCallStack("NotExpr", "JmmGrammar.jj", 5130);
            try {
                OtherExpr();
            }
            finally {
                popCallStack();
            }
        }
        else  {
            pushOntoCallStack("NotExpr", "JmmGrammar.jj", 5096);
            throw new ParseException(this, NotExpr_FIRST_SET, parsingStack);
        }
    }

    // JmmGrammar.jj:187:1
    final public void OtherExpr() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "OtherExpr";
        // Code for NonTerminal specified at:
        // JmmGrammar.jj:188:9
        pushOntoCallStack("OtherExpr", "JmmGrammar.jj", 5174);
        try {
            OtherPre();
        }
        finally {
            popCallStack();
        }
        // Code for ZeroOrMore specified at:
        // JmmGrammar.jj:188:18
        while (true) {
            if (!(nextTokenType()== DOT||nextTokenType== OPEN_RET)) break;
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:188:19
            AccessExpression OtherExpr24= null;
            if (buildTree) {
                OtherExpr24= new AccessExpression();
                openNodeScope(OtherExpr24);
            }
            ParseException parseException683= null;
            int callStackSize684= parsingStack.size();
            try {
                if (false) throw new ParseException("Never happens!");
                pushOntoCallStack("OtherExpr", "JmmGrammar.jj", 5184);
                try {
                    OtherSu();
                }
                finally {
                    popCallStack();
                }
            }
            catch(ParseException e) {
                parseException683= e;
                throw e;
            }
            finally {
                restoreCallStack(callStackSize684);
                if (OtherExpr24!=null) {
                    if (parseException683== null) {
                        closeNodeScope(OtherExpr24, 2);
                    }
                    else  {
                        clearNodeScope();
                    }
                }
                this.currentlyParsedProduction= prevProduction;
            }
        }
    }

    static private final EnumSet<TokenType> OtherPre_FIRST_SET= tokenTypeSet(OPEN_PAREN, INTEGER, TRUE, FALSE, THIS, NEW, IDENTIFIER);
    // JmmGrammar.jj:191:1
    final public void OtherPre() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "OtherPre";
        // Code for ExpansionChoice specified at:
        // JmmGrammar.jj:192:9
        if (nextTokenType()== INTEGER||nextTokenType== TRUE||nextTokenType== FALSE) {
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:192:9
            pushOntoCallStack("OtherPre", "JmmGrammar.jj", 5248);
            try {
                Literal();
            }
            finally {
                popCallStack();
            }
        }
        else if (nextTokenType()== THIS) {
            Variable OtherPre25= null;
            if (buildTree) {
                OtherPre25= new Variable();
                openNodeScope(OtherPre25);
            }
            ParseException parseException698= null;
            int callStackSize699= parsingStack.size();
            try {
                if (false) throw new ParseException("Never happens!");
                // Code for RegexpRef specified at:
                // JmmGrammar.jj:192:20
                consumeToken(THIS);
                // Code for CodeBlock specified at:
                // JmmGrammar.jj:192:27
                OtherPre25.put("name", "this");
            }
            catch(ParseException e) {
                parseException698= e;
                throw e;
            }
            finally {
                restoreCallStack(callStackSize699);
                if (OtherPre25!=null) {
                    if (parseException698== null) {
                        closeNodeScope(OtherPre25, true);
                    }
                    else  {
                        clearNodeScope();
                    }
                }
                this.currentlyParsedProduction= prevProduction;
            }
        }
        else if (nextTokenType()== IDENTIFIER) {
            Variable OtherPre26= null;
            if (buildTree) {
                OtherPre26= new Variable();
                openNodeScope(OtherPre26);
            }
            ParseException parseException711= null;
            int callStackSize712= parsingStack.size();
            try {
                if (false) throw new ParseException("Never happens!");
                // Code for RegexpRef specified at:
                // JmmGrammar.jj:192:74
                consumeToken(IDENTIFIER);
                // Code for CodeBlock specified at:
                // JmmGrammar.jj:192:87
                OtherPre26.put("name", lastConsumedToken.getImage());
            }
            catch(ParseException e) {
                parseException711= e;
                throw e;
            }
            finally {
                restoreCallStack(callStackSize712);
                if (OtherPre26!=null) {
                    if (parseException711== null) {
                        closeNodeScope(OtherPre26, true);
                    }
                    else  {
                        clearNodeScope();
                    }
                }
                this.currentlyParsedProduction= prevProduction;
            }
        }
        else if (nextTokenType()== OPEN_PAREN) {
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:192:155
            consumeToken(OPEN_PAREN);
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:192:168
            pushOntoCallStack("OtherPre", "JmmGrammar.jj", 5407);
            try {
                Expr();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:192:173
            consumeToken(CLOSE_PAREN);
        }
        else if (nextTokenType()== NEW) {
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:192:189
            pushOntoCallStack("OtherPre", "JmmGrammar.jj", 5428);
            try {
                NewExpr();
            }
            finally {
                popCallStack();
            }
        }
        else  {
            pushOntoCallStack("OtherPre", "JmmGrammar.jj", 5248);
            throw new ParseException(this, OtherPre_FIRST_SET, parsingStack);
        }
    }

    static private final EnumSet<TokenType> OtherSu_FIRST_SET= tokenTypeSet(DOT, OPEN_RET);
    // JmmGrammar.jj:195:1
    final public void OtherSu() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "OtherSu";
        // Code for ExpansionChoice specified at:
        // JmmGrammar.jj:196:9
        if (nextTokenType()== DOT) {
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:196:10
            consumeToken(DOT);
            if (nextTokenType()== NEW) {
                // Code for NonTerminal specified at:
                // JmmGrammar.jj:196:17
                pushOntoCallStack("OtherSu", "JmmGrammar.jj", 5477);
                try {
                    NewExpr();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== IDENTIFIER) {
                MethodCall OtherSu27= null;
                if (buildTree) {
                    OtherSu27= new MethodCall();
                    openNodeScope(OtherSu27);
                }
                ParseException parseException765= null;
                int callStackSize766= parsingStack.size();
                try {
                    if (false) throw new ParseException("Never happens!");
                    // Code for RegexpRef specified at:
                    // JmmGrammar.jj:197:10
                    consumeToken(IDENTIFIER);
                    // Code for CodeBlock specified at:
                    // JmmGrammar.jj:197:23
                    OtherSu27.put("value", lastConsumedToken.getImage());
                    // Code for ZeroOrOne specified at:
                    // JmmGrammar.jj:197:79
                    if (nextTokenType()== OPEN_PAREN) {
                        // Code for NonTerminal specified at:
                        // JmmGrammar.jj:197:80
                        pushOntoCallStack("OtherSu", "JmmGrammar.jj", 5566);
                        try {
                            MethodCall();
                        }
                        finally {
                            popCallStack();
                        }
                    }
                }
                catch(ParseException e) {
                    parseException765= e;
                    throw e;
                }
                finally {
                    restoreCallStack(callStackSize766);
                    if (OtherSu27!=null) {
                        if (parseException765== null) {
                            closeNodeScope(OtherSu27, true);
                        }
                        else  {
                            clearNodeScope();
                        }
                    }
                    this.currentlyParsedProduction= prevProduction;
                }
            }
            else if (nextTokenType()== COMPRIMENTO) {
                Length OtherSu28= null;
                if (buildTree) {
                    OtherSu28= new Length();
                    openNodeScope(OtherSu28);
                }
                ParseException parseException787= null;
                int callStackSize788= parsingStack.size();
                try {
                    if (false) throw new ParseException("Never happens!");
                    // Code for RegexpRef specified at:
                    // JmmGrammar.jj:198:10
                    consumeToken(COMPRIMENTO);
                }
                catch(ParseException e) {
                    parseException787= e;
                    throw e;
                }
                finally {
                    restoreCallStack(callStackSize788);
                    if (OtherSu28!=null) {
                        if (parseException787== null) {
                            closeNodeScope(OtherSu28, true);
                        }
                        else  {
                            clearNodeScope();
                        }
                    }
                    this.currentlyParsedProduction= prevProduction;
                }
            }
            else  {
                pushOntoCallStack("OtherSu", "JmmGrammar.jj", 5477);
                throw new ParseException(this, first_set$JmmGrammar_jj$196$17, parsingStack);
            }
        }
        else if (nextTokenType()== OPEN_RET) {
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:200:9
            consumeToken(OPEN_RET);
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:200:20
            ArrayAccess OtherSu29= null;
            if (buildTree) {
                OtherSu29= new ArrayAccess();
                openNodeScope(OtherSu29);
            }
            ParseException parseException800= null;
            int callStackSize801= parsingStack.size();
            try {
                if (false) throw new ParseException("Never happens!");
                pushOntoCallStack("OtherSu", "JmmGrammar.jj", 5650);
                try {
                    Expr();
                }
                finally {
                    popCallStack();
                }
            }
            catch(ParseException e) {
                parseException800= e;
                throw e;
            }
            finally {
                restoreCallStack(callStackSize801);
                if (OtherSu29!=null) {
                    if (parseException800== null) {
                        closeNodeScope(OtherSu29, true);
                    }
                    else  {
                        clearNodeScope();
                    }
                }
                this.currentlyParsedProduction= prevProduction;
            }
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:200:38
            consumeToken(CLOSE_RET);
        }
        else  {
            pushOntoCallStack("OtherSu", "JmmGrammar.jj", 5469);
            throw new ParseException(this, OtherSu_FIRST_SET, parsingStack);
        }
    }

    // JmmGrammar.jj:203:1
    final public void MethodCall() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "MethodCall";
        // Code for RegexpRef specified at:
        // JmmGrammar.jj:204:3
        consumeToken(OPEN_PAREN);
        // Code for ZeroOrOne specified at:
        // JmmGrammar.jj:204:16
        if (first_set$JmmGrammar_jj$204$17.contains(nextTokenType())) {
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:204:17
            pushOntoCallStack("MethodCall", "JmmGrammar.jj", 5723);
            try {
                Expr();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at:
            // JmmGrammar.jj:204:22
            while (true) {
                if (!(nextTokenType()== COMMA)) break;
                // Code for RegexpRef specified at:
                // JmmGrammar.jj:204:23
                consumeToken(COMMA);
                // Code for NonTerminal specified at:
                // JmmGrammar.jj:204:31
                pushOntoCallStack("MethodCall", "JmmGrammar.jj", 5737);
                try {
                    Expr();
                }
                finally {
                    popCallStack();
                }
            }
        }
        // Code for RegexpRef specified at:
        // JmmGrammar.jj:204:40
        consumeToken(CLOSE_PAREN);
    }

    static private final EnumSet<TokenType> Literal_FIRST_SET= tokenTypeSet(INTEGER, TRUE, FALSE);
    // JmmGrammar.jj:207:1
    final public void Literal() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Literal";
        // Code for ExpansionChoice specified at:
        // JmmGrammar.jj:208:9
        if (nextTokenType()== INTEGER) {
            IntegerLiteral Literal30= null;
            if (buildTree) {
                Literal30= new IntegerLiteral();
                openNodeScope(Literal30);
            }
            ParseException parseException842= null;
            int callStackSize843= parsingStack.size();
            try {
                if (false) throw new ParseException("Never happens!");
                // Code for RegexpRef specified at:
                // JmmGrammar.jj:208:10
                consumeToken(INTEGER);
                // Code for CodeBlock specified at:
                // JmmGrammar.jj:208:20
                Literal30.put("value", lastConsumedToken.getImage());
            }
            catch(ParseException e) {
                parseException842= e;
                throw e;
            }
            finally {
                restoreCallStack(callStackSize843);
                if (Literal30!=null) {
                    if (parseException842== null) {
                        closeNodeScope(Literal30, true);
                    }
                    else  {
                        clearNodeScope();
                    }
                }
                this.currentlyParsedProduction= prevProduction;
            }
        }
        else if (nextTokenType()== TRUE||nextTokenType== FALSE) {
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:208:94
            pushOntoCallStack("Literal", "JmmGrammar.jj", 5877);
            try {
                BooleanLiteral();
            }
            finally {
                popCallStack();
            }
        }
        else  {
            pushOntoCallStack("Literal", "JmmGrammar.jj", 5792);
            throw new ParseException(this, Literal_FIRST_SET, parsingStack);
        }
    }

    // JmmGrammar.jj:211:1
    final public void BooleanLiteral() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "BooleanLiteral";
        BooleanLiteral BooleanLiteral31= null;
        if (buildTree) {
            BooleanLiteral31= new BooleanLiteral();
            openNodeScope(BooleanLiteral31);
        }
        ParseException parseException858= null;
        int callStackSize859= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            if (nextTokenType()== TRUE) {
                // Code for RegexpRef specified at:
                // JmmGrammar.jj:212:10
                consumeToken(TRUE);
            }
            else if (nextTokenType()== FALSE) {
                // Code for RegexpRef specified at:
                // JmmGrammar.jj:212:19
                consumeToken(FALSE);
            }
            else  {
                pushOntoCallStack("BooleanLiteral", "JmmGrammar.jj", 5927);
                throw new ParseException(this, first_set$JmmGrammar_jj$212$10, parsingStack);
            }
            // Code for CodeBlock specified at:
            // JmmGrammar.jj:212:28
            BooleanLiteral31.put("value", lastConsumedToken.getImage());
        }
        catch(ParseException e) {
            parseException858= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize859);
            if (BooleanLiteral31!=null) {
                if (parseException858== null) {
                    closeNodeScope(BooleanLiteral31, true);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // JmmGrammar.jj:215:1
    final public void NewExpr() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "NewExpr";
        // Code for RegexpRef specified at:
        // JmmGrammar.jj:216:9
        consumeToken(NEW);
        if (nextTokenType()== INT) {
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:216:17
            consumeToken(INT);
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:216:23
            pushOntoCallStack("NewExpr", "JmmGrammar.jj", 6047);
            try {
                Array();
            }
            finally {
                popCallStack();
            }
        }
        else if (nextTokenType()== IDENTIFIER) {
            NewObject NewExpr32= null;
            if (buildTree) {
                NewExpr32= new NewObject();
                openNodeScope(NewExpr32);
            }
            ParseException parseException910= null;
            int callStackSize911= parsingStack.size();
            try {
                if (false) throw new ParseException("Never happens!");
                // Code for RegexpRef specified at:
                // JmmGrammar.jj:216:34
                consumeToken(IDENTIFIER);
                // Code for CodeBlock specified at:
                // JmmGrammar.jj:216:47
                NewExpr32.put("value", lastConsumedToken.getImage());
            }
            catch(ParseException e) {
                parseException910= e;
                throw e;
            }
            finally {
                restoreCallStack(callStackSize911);
                if (NewExpr32!=null) {
                    if (parseException910== null) {
                        closeNodeScope(NewExpr32, true);
                    }
                    else  {
                        clearNodeScope();
                    }
                }
                this.currentlyParsedProduction= prevProduction;
            }
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:216:115
            consumeToken(OPEN_PAREN);
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:216:128
            consumeToken(CLOSE_PAREN);
        }
        else  {
            pushOntoCallStack("NewExpr", "JmmGrammar.jj", 6040);
            throw new ParseException(this, first_set$JmmGrammar_jj$216$16, parsingStack);
        }
    }

    // JmmGrammar.jj:219:1
    final public void Array() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Array";
        Array Array33= null;
        if (buildTree) {
            Array33= new Array();
            openNodeScope(Array33);
        }
        ParseException parseException926= null;
        int callStackSize927= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:220:9
            consumeToken(OPEN_RET);
            // Code for NonTerminal specified at:
            // JmmGrammar.jj:220:20
            pushOntoCallStack("Array", "JmmGrammar.jj", 6203);
            try {
                Expr();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpRef specified at:
            // JmmGrammar.jj:220:25
            consumeToken(CLOSE_RET);
        }
        catch(ParseException e) {
            parseException926= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize927);
            if (Array33!=null) {
                if (parseException926== null) {
                    closeNodeScope(Array33, true);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> first_set$JmmGrammar_jj$75$17= tokenTypeSet(INT, BOOL, STRING, VOID, IDENTIFIER);
    static private final EnumSet<TokenType> first_set$JmmGrammar_jj$100$9= tokenTypeSet(INT, BOOL, STRING, VOID, IDENTIFIER);
    static private final EnumSet<TokenType> first_set$JmmGrammar_jj$105$17= tokenTypeSet(INT, BOOL, STRING, VOID, IDENTIFIER);
    static private final EnumSet<TokenType> first_set$JmmGrammar_jj$113$17= first_set$JmmGrammar_jj$113$17_init();
    static private EnumSet<TokenType> first_set$JmmGrammar_jj$113$17_init() {
        return tokenTypeSet(OPEN_PAREN, INTEGER, OPEN_CHAV, IF, WHILE, TRUE, FALSE, THIS, NEW, EXCL, IDENTIFIER);
    }

    static private final EnumSet<TokenType> first_set$JmmGrammar_jj$124$17= first_set$JmmGrammar_jj$124$17_init();
    static private EnumSet<TokenType> first_set$JmmGrammar_jj$124$17_init() {
        return tokenTypeSet(OPEN_PAREN, INTEGER, OPEN_CHAV, IF, WHILE, TRUE, FALSE, THIS, NEW, EXCL, IDENTIFIER);
    }

    static private final EnumSet<TokenType> first_set$JmmGrammar_jj$157$17= first_set$JmmGrammar_jj$157$17_init();
    static private EnumSet<TokenType> first_set$JmmGrammar_jj$157$17_init() {
        return tokenTypeSet(OPEN_PAREN, INTEGER, OPEN_CHAV, IF, WHILE, TRUE, FALSE, THIS, NEW, EXCL, IDENTIFIER);
    }

    static private final EnumSet<TokenType> first_set$JmmGrammar_jj$164$9= first_set$JmmGrammar_jj$164$9_init();
    static private EnumSet<TokenType> first_set$JmmGrammar_jj$164$9_init() {
        return tokenTypeSet(OPEN_PAREN, INTEGER, TRUE, FALSE, THIS, NEW, EXCL, IDENTIFIER);
    }

    static private final EnumSet<TokenType> first_set$JmmGrammar_jj$176$20= tokenTypeSet(PLUS, MINUS);
    static private final EnumSet<TokenType> first_set$JmmGrammar_jj$180$20= tokenTypeSet(TIMES, DIVIDE);
    static private final EnumSet<TokenType> first_set$JmmGrammar_jj$184$43= tokenTypeSet(OPEN_PAREN, INTEGER, TRUE, FALSE, THIS, NEW, IDENTIFIER);
    static private final EnumSet<TokenType> first_set$JmmGrammar_jj$192$9= tokenTypeSet(INTEGER, TRUE, FALSE);
    static private final EnumSet<TokenType> first_set$JmmGrammar_jj$196$17= tokenTypeSet(COMPRIMENTO, NEW, IDENTIFIER);
    static private final EnumSet<TokenType> first_set$JmmGrammar_jj$204$17= first_set$JmmGrammar_jj$204$17_init();
    static private EnumSet<TokenType> first_set$JmmGrammar_jj$204$17_init() {
        return tokenTypeSet(OPEN_PAREN, INTEGER, TRUE, FALSE, THIS, NEW, EXCL, IDENTIFIER);
    }

    static private final EnumSet<TokenType> first_set$JmmGrammar_jj$212$10= tokenTypeSet(TRUE, FALSE);
    static private final EnumSet<TokenType> first_set$JmmGrammar_jj$216$16= tokenTypeSet(INT, IDENTIFIER);
    private final boolean scanToken(TokenType expectedType) {
        Token peekedToken= nextToken(currentLookaheadToken);
        TokenType type= peekedToken.getType();
        if (type!=expectedType) return lastLookaheadSucceeded= false;
        if (remainingLookahead!=UNLIMITED) remainingLookahead--;
        currentLookaheadToken= peekedToken;
        return lastLookaheadSucceeded= true;
    }

    private final boolean scanToken(EnumSet<TokenType> types) {
        Token peekedToken= nextToken(currentLookaheadToken);
        TokenType type= peekedToken.getType();
        if (!types.contains(type)) return lastLookaheadSucceeded= false;
        if (remainingLookahead!=UNLIMITED) remainingLookahead--;
        //     if (type == upToTokenType) remainingLookahead = 0;
        currentLookaheadToken= peekedToken;
        return lastLookaheadSucceeded= true;
    }

    // scanahead routine for expansion at: 
    // JmmGrammar.jj:130:9
    // BuildScanRoutine macro
    private final boolean check$JmmGrammar_jj$130$9() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return lastLookaheadSucceeded= true;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at JmmGrammar.jj:130:22
            if (!scanToken(INT)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at JmmGrammar.jj:130:28
            if (!scanToken(OPEN_RET)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at JmmGrammar.jj:130:39
            if (!scanToken(CLOSE_RET)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for CodeBlock specified at JmmGrammar.jj:130:51
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // JmmGrammar.jj:163:91
    // BuildScanRoutine macro
    private final boolean check$JmmGrammar_jj$163$91() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return lastLookaheadSucceeded= true;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at JmmGrammar.jj:163:92
            if (!scanToken(OPEN_RET)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at JmmGrammar.jj:163:103
            pushOntoLookaheadStack("Statement", "JmmGrammar.jj", 4477);
            String prevProduction967= currentLookaheadProduction;
            currentLookaheadProduction= "Expr";
            scanToEnd= true;
            try {
                if (!check$Expr()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction967;
            }
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at JmmGrammar.jj:163:108
            if (!scanToken(CLOSE_RET)) return lastLookaheadSucceeded= false;
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // JmmGrammar.jj:168:18
    // BuildScanRoutine macro
    private final boolean check$JmmGrammar_jj$168$18() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return lastLookaheadSucceeded= true;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at JmmGrammar.jj:168:19
            if (!scanToken(AND)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at JmmGrammar.jj:168:25
            pushOntoLookaheadStack("Expr", "JmmGrammar.jj", 4620);
            String prevProduction971= currentLookaheadProduction;
            currentLookaheadProduction= "RelExpr";
            scanToEnd= true;
            try {
                if (!check$RelExpr()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction971;
            }
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for CodeBlock specified at JmmGrammar.jj:168:33
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // JmmGrammar.jj:172:18
    // BuildScanRoutine macro
    private final boolean check$JmmGrammar_jj$172$18() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return lastLookaheadSucceeded= true;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at JmmGrammar.jj:172:19
            if (!scanToken(LESS)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at JmmGrammar.jj:172:26
            pushOntoLookaheadStack("RelExpr", "JmmGrammar.jj", 4728);
            String prevProduction973= currentLookaheadProduction;
            currentLookaheadProduction= "AddExpr";
            scanToEnd= true;
            try {
                if (!check$AddExpr()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction973;
            }
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for CodeBlock specified at JmmGrammar.jj:172:34
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // JmmGrammar.jj:176:18
    // BuildScanRoutine macro
    private final boolean check$JmmGrammar_jj$176$18() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return lastLookaheadSucceeded= true;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for ExpansionChoice specified at JmmGrammar.jj:176:20
            if (!scanToken(first_set$JmmGrammar_jj$176$20)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for CodeBlock specified at JmmGrammar.jj:176:38
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at JmmGrammar.jj:176:91
            pushOntoLookaheadStack("AddExpr", "JmmGrammar.jj", 4906);
            String prevProduction975= currentLookaheadProduction;
            currentLookaheadProduction= "MulExpr";
            scanToEnd= true;
            try {
                if (!check$MulExpr()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction975;
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // JmmGrammar.jj:180:18
    // BuildScanRoutine macro
    private final boolean check$JmmGrammar_jj$180$18() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return lastLookaheadSucceeded= true;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for ExpansionChoice specified at JmmGrammar.jj:180:20
            if (!scanToken(first_set$JmmGrammar_jj$180$20)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for CodeBlock specified at JmmGrammar.jj:180:40
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at JmmGrammar.jj:180:93
            pushOntoLookaheadStack("MulExpr", "JmmGrammar.jj", 5043);
            String prevProduction977= currentLookaheadProduction;
            currentLookaheadProduction= "NotExpr";
            scanToEnd= true;
            try {
                if (!check$NotExpr()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction977;
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // JmmGrammar.jj:184:9
    // BuildScanRoutine macro
    private final boolean check$JmmGrammar_jj$184$9() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return lastLookaheadSucceeded= true;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at JmmGrammar.jj:184:10
            if (!scanToken(EXCL)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at JmmGrammar.jj:184:17
            pushOntoLookaheadStack("NotExpr", "JmmGrammar.jj", 5104);
            String prevProduction979= currentLookaheadProduction;
            currentLookaheadProduction= "NotExpr";
            scanToEnd= true;
            try {
                if (!check$NotExpr()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction979;
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // JmmGrammar.jj:184:43
    // BuildScanRoutine macro
    private final boolean check$JmmGrammar_jj$184$43() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return lastLookaheadSucceeded= true;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at JmmGrammar.jj:184:43
            pushOntoLookaheadStack("NotExpr", "JmmGrammar.jj", 5130);
            String prevProduction981= currentLookaheadProduction;
            currentLookaheadProduction= "OtherExpr";
            scanToEnd= false;
            try {
                if (!check$OtherExpr()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction981;
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // JmmGrammar.jj:188:19
    // BuildScanRoutine macro
    private final boolean check$JmmGrammar_jj$188$19() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return lastLookaheadSucceeded= true;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at JmmGrammar.jj:188:19
            pushOntoLookaheadStack("OtherExpr", "JmmGrammar.jj", 5184);
            String prevProduction982= currentLookaheadProduction;
            currentLookaheadProduction= "OtherSu";
            scanToEnd= false;
            try {
                if (!check$OtherSu()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction982;
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // JmmGrammar.jj:192:155
    // BuildScanRoutine macro
    private final boolean check$JmmGrammar_jj$192$155() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return lastLookaheadSucceeded= true;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at JmmGrammar.jj:192:155
            if (!scanToken(OPEN_PAREN)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at JmmGrammar.jj:192:168
            pushOntoLookaheadStack("OtherPre", "JmmGrammar.jj", 5407);
            String prevProduction983= currentLookaheadProduction;
            currentLookaheadProduction= "Expr";
            scanToEnd= true;
            try {
                if (!check$Expr()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction983;
            }
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at JmmGrammar.jj:192:173
            if (!scanToken(CLOSE_PAREN)) return lastLookaheadSucceeded= false;
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // JmmGrammar.jj:192:189
    // BuildScanRoutine macro
    private final boolean check$JmmGrammar_jj$192$189() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return lastLookaheadSucceeded= true;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at JmmGrammar.jj:192:189
            pushOntoLookaheadStack("OtherPre", "JmmGrammar.jj", 5428);
            String prevProduction984= currentLookaheadProduction;
            currentLookaheadProduction= "NewExpr";
            scanToEnd= false;
            try {
                if (!check$NewExpr()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction984;
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // JmmGrammar.jj:196:9
    // BuildScanRoutine macro
    private final boolean check$JmmGrammar_jj$196$9() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return lastLookaheadSucceeded= true;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at JmmGrammar.jj:196:10
            if (!scanToken(DOT)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for ExpansionChoice specified at JmmGrammar.jj:196:17
            Token token985= currentLookaheadToken;
            int remainingLookahead985= remainingLookahead;
            boolean hitFailure985= hitFailure;
            if (!check$JmmGrammar_jj$196$17()) {
                currentLookaheadToken= token985;
                remainingLookahead= remainingLookahead985;
                hitFailure= hitFailure985;
                if (!check$JmmGrammar_jj$197$9()) {
                    currentLookaheadToken= token985;
                    remainingLookahead= remainingLookahead985;
                    hitFailure= hitFailure985;
                    if (!scanToken(COMPRIMENTO)) {
                        currentLookaheadToken= token985;
                        remainingLookahead= remainingLookahead985;
                        hitFailure= hitFailure985;
                        return lastLookaheadSucceeded= false;
                    }
                }
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // JmmGrammar.jj:196:17
    // BuildScanRoutine macro
    private final boolean check$JmmGrammar_jj$196$17() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return lastLookaheadSucceeded= true;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at JmmGrammar.jj:196:17
            pushOntoLookaheadStack("OtherSu", "JmmGrammar.jj", 5477);
            String prevProduction987= currentLookaheadProduction;
            currentLookaheadProduction= "NewExpr";
            scanToEnd= false;
            try {
                if (!check$NewExpr()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction987;
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // JmmGrammar.jj:197:9
    // BuildScanRoutine macro
    private final boolean check$JmmGrammar_jj$197$9() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return lastLookaheadSucceeded= true;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at JmmGrammar.jj:197:10
            if (!scanToken(IDENTIFIER)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for CodeBlock specified at JmmGrammar.jj:197:23
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for ZeroOrOne specified at JmmGrammar.jj:197:79
            Token token988= currentLookaheadToken;
            if (!check$JmmGrammar_jj$197$80()) currentLookaheadToken= token988;
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // JmmGrammar.jj:197:80
    // BuildScanRoutine macro
    private final boolean check$JmmGrammar_jj$197$80() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return lastLookaheadSucceeded= true;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at JmmGrammar.jj:197:80
            pushOntoLookaheadStack("OtherSu", "JmmGrammar.jj", 5566);
            String prevProduction990= currentLookaheadProduction;
            currentLookaheadProduction= "MethodCall";
            scanToEnd= false;
            try {
                if (!check$MethodCall()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction990;
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // JmmGrammar.jj:200:9
    // BuildScanRoutine macro
    private final boolean check$JmmGrammar_jj$200$9() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return lastLookaheadSucceeded= true;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at JmmGrammar.jj:200:9
            if (!scanToken(OPEN_RET)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at JmmGrammar.jj:200:20
            pushOntoLookaheadStack("OtherSu", "JmmGrammar.jj", 5650);
            String prevProduction991= currentLookaheadProduction;
            currentLookaheadProduction= "Expr";
            scanToEnd= true;
            try {
                if (!check$Expr()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction991;
            }
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at JmmGrammar.jj:200:38
            if (!scanToken(CLOSE_RET)) return lastLookaheadSucceeded= false;
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // JmmGrammar.jj:204:17
    // BuildScanRoutine macro
    private final boolean check$JmmGrammar_jj$204$17() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return lastLookaheadSucceeded= true;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at JmmGrammar.jj:204:17
            pushOntoLookaheadStack("MethodCall", "JmmGrammar.jj", 5723);
            String prevProduction992= currentLookaheadProduction;
            currentLookaheadProduction= "Expr";
            scanToEnd= false;
            try {
                if (!check$Expr()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction992;
            }
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for ZeroOrMore specified at JmmGrammar.jj:204:22
            while (remainingLookahead> 0&&!hitFailure) {
                Token token993= currentLookaheadToken;
                if (!check$JmmGrammar_jj$204$23()) {
                    currentLookaheadToken= token993;
                    break;
                }
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // JmmGrammar.jj:204:23
    // BuildScanRoutine macro
    private final boolean check$JmmGrammar_jj$204$23() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return lastLookaheadSucceeded= true;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at JmmGrammar.jj:204:23
            if (!scanToken(COMMA)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at JmmGrammar.jj:204:31
            pushOntoLookaheadStack("MethodCall", "JmmGrammar.jj", 5737);
            String prevProduction994= currentLookaheadProduction;
            currentLookaheadProduction= "Expr";
            scanToEnd= true;
            try {
                if (!check$Expr()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction994;
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // JmmGrammar.jj:216:16
    // BuildScanRoutine macro
    private final boolean check$JmmGrammar_jj$216$16() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return lastLookaheadSucceeded= true;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at JmmGrammar.jj:216:17
            if (!scanToken(INT)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at JmmGrammar.jj:216:23
            pushOntoLookaheadStack("NewExpr", "JmmGrammar.jj", 6047);
            String prevProduction995= currentLookaheadProduction;
            currentLookaheadProduction= "Array";
            scanToEnd= true;
            try {
                if (!check$Array()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction995;
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // JmmGrammar.jj:216:32
    // BuildScanRoutine macro
    private final boolean check$JmmGrammar_jj$216$32() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return lastLookaheadSucceeded= true;
            if (!scanToken(IDENTIFIER)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at JmmGrammar.jj:216:115
            if (!scanToken(OPEN_PAREN)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at JmmGrammar.jj:216:128
            if (!scanToken(CLOSE_PAREN)) return lastLookaheadSucceeded= false;
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // predicate routine for expansion at: 
    // JmmGrammar.jj:110:17
    // BuildPredicateRoutine macro
    private final boolean scan$JmmGrammar_jj$110$17() {
        try {
            lookaheadRoutineNesting++;
            currentLookaheadToken= lastConsumedToken;
            remainingLookahead= 2;
            hitFailure= false;
            scanToEnd= true;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return lastLookaheadSucceeded= true;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at JmmGrammar.jj:110:30
            pushOntoLookaheadStack("ClassMethod", "JmmGrammar.jj", 3028);
            String prevProduction997= currentLookaheadProduction;
            currentLookaheadProduction= "VarDeclaration";
            scanToEnd= true;
            try {
                if (!check$VarDeclaration()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction997;
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
            currentLookaheadToken= null;
        }
    }

    // predicate routine for expansion at: 
    // JmmGrammar.jj:121:17
    // BuildPredicateRoutine macro
    private final boolean scan$JmmGrammar_jj$121$17() {
        try {
            lookaheadRoutineNesting++;
            currentLookaheadToken= lastConsumedToken;
            remainingLookahead= 2;
            hitFailure= false;
            scanToEnd= true;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return lastLookaheadSucceeded= true;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at JmmGrammar.jj:121:30
            pushOntoLookaheadStack("MainMethod", "JmmGrammar.jj", 3453);
            String prevProduction998= currentLookaheadProduction;
            currentLookaheadProduction= "VarDeclaration";
            scanToEnd= true;
            try {
                if (!check$VarDeclaration()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction998;
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
            currentLookaheadToken= null;
        }
    }

    // predicate routine for expansion at: 
    // JmmGrammar.jj:130:9
    // BuildPredicateRoutine macro
    private final boolean scan$JmmGrammar_jj$130$9() {
        try {
            lookaheadRoutineNesting++;
            currentLookaheadToken= lastConsumedToken;
            remainingLookahead= 2;
            hitFailure= false;
            scanToEnd= true;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return lastLookaheadSucceeded= true;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at JmmGrammar.jj:130:22
            if (!scanToken(INT)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at JmmGrammar.jj:130:28
            if (!scanToken(OPEN_RET)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at JmmGrammar.jj:130:39
            if (!scanToken(CLOSE_RET)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for CodeBlock specified at JmmGrammar.jj:130:51
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
            currentLookaheadToken= null;
        }
    }

    // predicate routine for expansion at: 
    // JmmGrammar.jj:163:9
    // BuildPredicateRoutine macro
    private final boolean scan$JmmGrammar_jj$163$9() {
        try {
            lookaheadRoutineNesting++;
            currentLookaheadToken= lastConsumedToken;
            remainingLookahead= 2;
            hitFailure= false;
            scanToEnd= true;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return lastLookaheadSucceeded= true;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at JmmGrammar.jj:163:23
            if (!scanToken(IDENTIFIER)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for CodeBlock specified at JmmGrammar.jj:163:36
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for ZeroOrOne specified at JmmGrammar.jj:163:90
            Token token999= currentLookaheadToken;
            if (!check$JmmGrammar_jj$163$91()) currentLookaheadToken= token999;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at JmmGrammar.jj:163:136
            if (!scanToken(EQUAL)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at JmmGrammar.jj:163:144
            pushOntoLookaheadStack("Statement", "JmmGrammar.jj", 4518);
            String prevProduction1000= currentLookaheadProduction;
            currentLookaheadProduction= "Expr";
            scanToEnd= true;
            try {
                if (!check$Expr()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction1000;
            }
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at JmmGrammar.jj:163:149
            if (!scanToken(NEXTLINE)) return lastLookaheadSucceeded= false;
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
            currentLookaheadToken= null;
        }
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$VarDeclaration() {
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for NonTerminal specified at JmmGrammar.jj:84:9
        pushOntoLookaheadStack("VarDeclaration", "JmmGrammar.jj", 2293);
        String prevProduction1008= currentLookaheadProduction;
        currentLookaheadProduction= "Type";
        scanToEnd= false;
        try {
            if (!check$Type()) return lastLookaheadSucceeded= false;
        }
        finally {
            popLookaheadStack();
            currentLookaheadProduction= prevProduction1008;
        }
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for RegexpRef specified at JmmGrammar.jj:84:19
        if (!scanToken(IDENTIFIER)) return lastLookaheadSucceeded= false;
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for CodeBlock specified at JmmGrammar.jj:84:32
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for RegexpRef specified at JmmGrammar.jj:84:112
        if (!scanToken(NEXTLINE)) return lastLookaheadSucceeded= false;
        return lastLookaheadSucceeded= true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Type() {
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for ExpansionChoice specified at JmmGrammar.jj:130:9
        Token token1020= currentLookaheadToken;
        int remainingLookahead1020= remainingLookahead;
        boolean hitFailure1020= hitFailure;
        if (!check$JmmGrammar_jj$130$9()) {
            currentLookaheadToken= token1020;
            remainingLookahead= remainingLookahead1020;
            hitFailure= hitFailure1020;
            if (!scanToken(BOOL)) {
                currentLookaheadToken= token1020;
                remainingLookahead= remainingLookahead1020;
                hitFailure= hitFailure1020;
                if (!scanToken(INT)) {
                    currentLookaheadToken= token1020;
                    remainingLookahead= remainingLookahead1020;
                    hitFailure= hitFailure1020;
                    if (!scanToken(STRING)) {
                        currentLookaheadToken= token1020;
                        remainingLookahead= remainingLookahead1020;
                        hitFailure= hitFailure1020;
                        if (!scanToken(VOID)) {
                            currentLookaheadToken= token1020;
                            remainingLookahead= remainingLookahead1020;
                            hitFailure= hitFailure1020;
                            if (!scanToken(IDENTIFIER)) {
                                currentLookaheadToken= token1020;
                                remainingLookahead= remainingLookahead1020;
                                hitFailure= hitFailure1020;
                                return lastLookaheadSucceeded= false;
                            }
                        }
                    }
                }
            }
        }
        return lastLookaheadSucceeded= true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Expr() {
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for NonTerminal specified at JmmGrammar.jj:168:9
        pushOntoLookaheadStack("Expr", "JmmGrammar.jj", 4604);
        String prevProduction1029= currentLookaheadProduction;
        currentLookaheadProduction= "RelExpr";
        scanToEnd= false;
        try {
            if (!check$RelExpr()) return lastLookaheadSucceeded= false;
        }
        finally {
            popLookaheadStack();
            currentLookaheadProduction= prevProduction1029;
        }
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for ZeroOrMore specified at JmmGrammar.jj:168:17
        while (remainingLookahead> 0&&!hitFailure) {
            Token token1030= currentLookaheadToken;
            if (!check$JmmGrammar_jj$168$18()) {
                currentLookaheadToken= token1030;
                break;
            }
        }
        return lastLookaheadSucceeded= true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$RelExpr() {
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for NonTerminal specified at JmmGrammar.jj:172:9
        pushOntoLookaheadStack("RelExpr", "JmmGrammar.jj", 4711);
        String prevProduction1031= currentLookaheadProduction;
        currentLookaheadProduction= "AddExpr";
        scanToEnd= false;
        try {
            if (!check$AddExpr()) return lastLookaheadSucceeded= false;
        }
        finally {
            popLookaheadStack();
            currentLookaheadProduction= prevProduction1031;
        }
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for ZeroOrMore specified at JmmGrammar.jj:172:17
        while (remainingLookahead> 0&&!hitFailure) {
            Token token1032= currentLookaheadToken;
            if (!check$JmmGrammar_jj$172$18()) {
                currentLookaheadToken= token1032;
                break;
            }
        }
        return lastLookaheadSucceeded= true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$AddExpr() {
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for NonTerminal specified at JmmGrammar.jj:176:9
        pushOntoLookaheadStack("AddExpr", "JmmGrammar.jj", 4824);
        String prevProduction1033= currentLookaheadProduction;
        currentLookaheadProduction= "MulExpr";
        scanToEnd= false;
        try {
            if (!check$MulExpr()) return lastLookaheadSucceeded= false;
        }
        finally {
            popLookaheadStack();
            currentLookaheadProduction= prevProduction1033;
        }
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for ZeroOrMore specified at JmmGrammar.jj:176:17
        while (remainingLookahead> 0&&!hitFailure) {
            Token token1034= currentLookaheadToken;
            if (!check$JmmGrammar_jj$176$18()) {
                currentLookaheadToken= token1034;
                break;
            }
        }
        return lastLookaheadSucceeded= true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$MulExpr() {
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for NonTerminal specified at JmmGrammar.jj:180:9
        pushOntoLookaheadStack("MulExpr", "JmmGrammar.jj", 4959);
        String prevProduction1035= currentLookaheadProduction;
        currentLookaheadProduction= "NotExpr";
        scanToEnd= false;
        try {
            if (!check$NotExpr()) return lastLookaheadSucceeded= false;
        }
        finally {
            popLookaheadStack();
            currentLookaheadProduction= prevProduction1035;
        }
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for ZeroOrMore specified at JmmGrammar.jj:180:17
        while (remainingLookahead> 0&&!hitFailure) {
            Token token1036= currentLookaheadToken;
            if (!check$JmmGrammar_jj$180$18()) {
                currentLookaheadToken= token1036;
                break;
            }
        }
        return lastLookaheadSucceeded= true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$NotExpr() {
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for ExpansionChoice specified at JmmGrammar.jj:184:9
        Token token1037= currentLookaheadToken;
        int remainingLookahead1037= remainingLookahead;
        boolean hitFailure1037= hitFailure;
        if (!check$JmmGrammar_jj$184$9()) {
            currentLookaheadToken= token1037;
            remainingLookahead= remainingLookahead1037;
            hitFailure= hitFailure1037;
            if (!check$JmmGrammar_jj$184$43()) {
                currentLookaheadToken= token1037;
                remainingLookahead= remainingLookahead1037;
                hitFailure= hitFailure1037;
                return lastLookaheadSucceeded= false;
            }
        }
        return lastLookaheadSucceeded= true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$OtherExpr() {
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for NonTerminal specified at JmmGrammar.jj:188:9
        pushOntoLookaheadStack("OtherExpr", "JmmGrammar.jj", 5174);
        String prevProduction1038= currentLookaheadProduction;
        currentLookaheadProduction= "OtherPre";
        scanToEnd= false;
        try {
            if (!check$OtherPre()) return lastLookaheadSucceeded= false;
        }
        finally {
            popLookaheadStack();
            currentLookaheadProduction= prevProduction1038;
        }
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for ZeroOrMore specified at JmmGrammar.jj:188:18
        while (remainingLookahead> 0&&!hitFailure) {
            Token token1039= currentLookaheadToken;
            if (!check$JmmGrammar_jj$188$19()) {
                currentLookaheadToken= token1039;
                break;
            }
        }
        return lastLookaheadSucceeded= true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$OtherPre() {
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for ExpansionChoice specified at JmmGrammar.jj:192:9
        Token token1040= currentLookaheadToken;
        int remainingLookahead1040= remainingLookahead;
        boolean hitFailure1040= hitFailure;
        if (!scanToken(first_set$JmmGrammar_jj$192$9)) {
            currentLookaheadToken= token1040;
            remainingLookahead= remainingLookahead1040;
            hitFailure= hitFailure1040;
            if (!scanToken(THIS)) {
                currentLookaheadToken= token1040;
                remainingLookahead= remainingLookahead1040;
                hitFailure= hitFailure1040;
                if (!scanToken(IDENTIFIER)) {
                    currentLookaheadToken= token1040;
                    remainingLookahead= remainingLookahead1040;
                    hitFailure= hitFailure1040;
                    if (!check$JmmGrammar_jj$192$155()) {
                        currentLookaheadToken= token1040;
                        remainingLookahead= remainingLookahead1040;
                        hitFailure= hitFailure1040;
                        if (!check$JmmGrammar_jj$192$189()) {
                            currentLookaheadToken= token1040;
                            remainingLookahead= remainingLookahead1040;
                            hitFailure= hitFailure1040;
                            return lastLookaheadSucceeded= false;
                        }
                    }
                }
            }
        }
        return lastLookaheadSucceeded= true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$OtherSu() {
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for ExpansionChoice specified at JmmGrammar.jj:196:9
        Token token1041= currentLookaheadToken;
        int remainingLookahead1041= remainingLookahead;
        boolean hitFailure1041= hitFailure;
        if (!check$JmmGrammar_jj$196$9()) {
            currentLookaheadToken= token1041;
            remainingLookahead= remainingLookahead1041;
            hitFailure= hitFailure1041;
            if (!check$JmmGrammar_jj$200$9()) {
                currentLookaheadToken= token1041;
                remainingLookahead= remainingLookahead1041;
                hitFailure= hitFailure1041;
                return lastLookaheadSucceeded= false;
            }
        }
        return lastLookaheadSucceeded= true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$MethodCall() {
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for RegexpRef specified at JmmGrammar.jj:204:3
        if (!scanToken(OPEN_PAREN)) return lastLookaheadSucceeded= false;
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for ZeroOrOne specified at JmmGrammar.jj:204:16
        Token token1042= currentLookaheadToken;
        if (!check$JmmGrammar_jj$204$17()) currentLookaheadToken= token1042;
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for RegexpRef specified at JmmGrammar.jj:204:40
        if (!scanToken(CLOSE_PAREN)) return lastLookaheadSucceeded= false;
        return lastLookaheadSucceeded= true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$NewExpr() {
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for RegexpRef specified at JmmGrammar.jj:216:9
        if (!scanToken(NEW)) return lastLookaheadSucceeded= false;
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for ExpansionChoice specified at JmmGrammar.jj:216:16
        Token token1043= currentLookaheadToken;
        int remainingLookahead1043= remainingLookahead;
        boolean hitFailure1043= hitFailure;
        if (!check$JmmGrammar_jj$216$16()) {
            currentLookaheadToken= token1043;
            remainingLookahead= remainingLookahead1043;
            hitFailure= hitFailure1043;
            if (!check$JmmGrammar_jj$216$32()) {
                currentLookaheadToken= token1043;
                remainingLookahead= remainingLookahead1043;
                hitFailure= hitFailure1043;
                return lastLookaheadSucceeded= false;
            }
        }
        return lastLookaheadSucceeded= true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Array() {
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for RegexpRef specified at JmmGrammar.jj:220:9
        if (!scanToken(OPEN_RET)) return lastLookaheadSucceeded= false;
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for NonTerminal specified at JmmGrammar.jj:220:20
        pushOntoLookaheadStack("Array", "JmmGrammar.jj", 6203);
        String prevProduction1044= currentLookaheadProduction;
        currentLookaheadProduction= "Expr";
        scanToEnd= true;
        try {
            if (!check$Expr()) return lastLookaheadSucceeded= false;
        }
        finally {
            popLookaheadStack();
            currentLookaheadProduction= prevProduction1044;
        }
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for RegexpRef specified at JmmGrammar.jj:220:25
        if (!scanToken(CLOSE_RET)) return lastLookaheadSucceeded= false;
        return lastLookaheadSucceeded= true;
    }

    ArrayList<NonTerminalCall> parsingStack= new ArrayList<> ();
    private ArrayList<NonTerminalCall> lookaheadStack= new ArrayList<> ();
    /**
 * Inner class that represents entering a grammar production
 */
    class NonTerminalCall {
        final String sourceFile;
        final String productionName;
        final int offset;
        // We actually only use this when we're working with the LookaheadStack
        final boolean scanToEnd;
        NonTerminalCall(String sourceFile, String productionName, int offset) {
            this.sourceFile= sourceFile;
            this.productionName= productionName;
            this.offset= offset;
            this.scanToEnd= JmmGrammarParser.this.scanToEnd;
        }

        final JmmGrammarLexer getTokenSource() {
            return JmmGrammarParser.this.token_source;
        }

        final int getLine() {
            return getTokenSource().getLineFromOffset(offset);
        }

        final int getColumn() {
            return getTokenSource().getCodePointColumnFromOffset(offset);
        }

        StackTraceElement createStackTraceElement() {
            return new StackTraceElement("JmmGrammarParser", productionName, sourceFile, getLine());
        }

        void dump(PrintStream ps) {
            ps.println(productionName+":"+getLine()+":"+getColumn());
        }

    }
    private final void pushOntoCallStack(String methodName, String fileName, int offset) {
        parsingStack.add(new NonTerminalCall(fileName, methodName, offset));
    }

    private final void popCallStack() {
        NonTerminalCall ntc= parsingStack.remove(parsingStack.size()-1);
        this.currentlyParsedProduction= ntc.productionName;
    }

    private final void restoreCallStack(int prevSize) {
        while (parsingStack.size()> prevSize) {
            popCallStack();
        }
    }

    private final void pushOntoLookaheadStack(String methodName, String fileName, int offset) {
        lookaheadStack.add(new NonTerminalCall(fileName, methodName, offset));
    }

    private final void popLookaheadStack() {
        NonTerminalCall ntc= lookaheadStack.remove(lookaheadStack.size()-1);
        this.currentLookaheadProduction= ntc.productionName;
        this.scanToEnd= ntc.scanToEnd;
    }

    void dumpLookaheadStack(PrintStream ps) {
        ListIterator<NonTerminalCall> it= lookaheadStack.listIterator(lookaheadStack.size());
        while (it.hasPrevious()) {
            it.previous().dump(ps);
        }
    }

    void dumpCallStack(PrintStream ps) {
        ListIterator<NonTerminalCall> it= parsingStack.listIterator(parsingStack.size());
        while (it.hasPrevious()) {
            it.previous().dump(ps);
        }
    }

    void dumpLookaheadCallStack(PrintStream ps) {
        ps.println("Current Parser Production is: "+currentlyParsedProduction);
        ps.println("Current Lookahead Production is: "+currentLookaheadProduction);
        ps.println("---Lookahead Stack---");
        dumpLookaheadStack(ps);
        ps.println("---Call Stack---");
        dumpCallStack(ps);
    }

    public boolean isParserTolerant() {
        return false;
    }

    public void setParserTolerant(boolean tolerantParsing) {
        if (tolerantParsing) {
            throw new UnsupportedOperationException("This parser was not built with that feature!");
        }
    }

    private Token consumeToken(TokenType expectedType) {
        Token oldToken= lastConsumedToken;
        Token nextToken= nextToken(lastConsumedToken);
        if (nextToken.getType()!=expectedType) {
            nextToken= handleUnexpectedTokenType(expectedType, nextToken);
        }
        this.lastConsumedToken= nextToken;
        this.nextTokenType= null;
        if (buildTree&&tokensAreNodes) {
            pushNode(lastConsumedToken);
        }
        return lastConsumedToken;
    }

    private Token handleUnexpectedTokenType(TokenType expectedType, Token nextToken) {
        throw new ParseException(nextToken, EnumSet.of(expectedType), parsingStack);
    }

    private class ParseState {
        Token lastConsumed;
        ArrayList<NonTerminalCall> parsingStack;
        NodeScope nodeScope;
        ParseState() {
            this.lastConsumed= JmmGrammarParser.this.lastConsumedToken;
            @SuppressWarnings("unchecked")
            ArrayList<NonTerminalCall> parsingStack= (ArrayList<NonTerminalCall> ) JmmGrammarParser.this.parsingStack.clone();
            this.parsingStack= parsingStack;
            this.nodeScope= (NodeScope) currentNodeScope.clone();
        }

    }
    private boolean buildTree= true;
    private boolean tokensAreNodes= false;
    private boolean unparsedTokensAreNodes= true;
    public boolean isTreeBuildingEnabled() {
        return buildTree;
    }

    public void setUnparsedTokensAreNodes(boolean unparsedTokensAreNodes) {
        this.unparsedTokensAreNodes= unparsedTokensAreNodes;
    }

    public void setTokensAreNodes(boolean tokensAreNodes) {
        this.tokensAreNodes= tokensAreNodes;
    }

    NodeScope currentNodeScope= new NodeScope();
    /** 
         * @return the root node of the AST. It only makes sense to call
         * this after a successful parse. 
         */
    public Node rootNode() {
        return currentNodeScope.rootNode();
    }

    /**
     * push a node onto the top of the node stack
     * @param n the node to push
     */
    public void pushNode(Node n) {
        currentNodeScope.add(n);
    }

    /** 
     * @return the node on the top of the stack, and remove it from the
     * stack.  
     */
    public Node popNode() {
        return currentNodeScope.pop();
    }

    /** 
     * @return the node currently on the top of the tree-building stack. 
     */
    public Node peekNode() {
        return currentNodeScope.peek();
    }

    /**
     * Puts the node on the top of the stack. However, unlike pushNode()
     * it replaces the node that is currently on the top of the stack.
     * This is effectively equivalent to popNode() followed by pushNode(n)
     * @param n the node to poke
     */
    public void pokeNode(Node n) {
        currentNodeScope.poke(n);
    }

    /** 
     * @return the number of Nodes on the tree-building stack in the current node
         * scope. 
         */
    public int nodeArity() {
        return currentNodeScope.size();
    }

    private void clearNodeScope() {
        currentNodeScope.clear();
    }

    private void openNodeScope(Node n) {
        new NodeScope();
        if (n!=null) {
            Token next= nextToken(lastConsumedToken);
            n.setTokenSource(lastConsumedToken.getTokenSource());
            n.setBeginOffset(next.getBeginOffset());
            n.open();
        }
    }

    /* A definite node is constructed from a specified number of
         * children.  That number of nodes are popped from the stack and
         * made the children of the definite node.  Then the definite node
         * is pushed on to the stack.
         */
    private void closeNodeScope(Node n, int num) {
        n.setEndOffset(lastConsumedToken.getEndOffset());
        currentNodeScope.close();
        ArrayList<Node> nodes= new ArrayList<Node> ();
        for (int i= 0; i<num; i++) {
            nodes.add(popNode());
        }
        Collections.reverse(nodes);
        for (Node child : nodes) {
            // FIXME deal with the UNPARSED_TOKENS_ARE_NODES case
            n.addChild(child);
        }
        n.close();
        pushNode(n);
    }

    /**
         * A conditional node is constructed if the condition is true.  All
         * the nodes that have been pushed since the node was opened are
         * made children of the conditional node, which is then pushed
         * on to the stack.  If the condition is false the node is not
         * constructed and they are left on the stack. 
         */
    private void closeNodeScope(Node n, boolean condition) {
        if (n!=null&&condition) {
            n.setEndOffset(lastConsumedToken.getEndOffset());
            int a= nodeArity();
            currentNodeScope.close();
            ArrayList<Node> nodes= new ArrayList<Node> ();
            while (a--> 0) {
                nodes.add(popNode());
            }
            Collections.reverse(nodes);
            for (Node child : nodes) {
                if (unparsedTokensAreNodes&&child instanceof Token) {
                    Token tok= (Token) child;
                    while (tok.previousCachedToken()!=null&&tok.previousCachedToken().isUnparsed()) {
                        tok= tok.previousCachedToken();
                    }
                    while (tok.isUnparsed()) {
                        n.addChild(tok);
                        tok= tok.nextCachedToken();
                    }
                }
                n.addChild(child);
            }
            n.close();
            pushNode(n);
        }
        else  {
            currentNodeScope.close();
        }
    }

    public boolean getBuildTree() {
        return buildTree;
    }

    public void setBuildTree(boolean buildTree) {
        this.buildTree= buildTree;
    }

    /**
     * Just a kludge so that existing jjtree-based code that uses
     * parser.jjtree.foo can work without change.
     */
    JmmGrammarParser jjtree= this;
    @SuppressWarnings("serial")
    class NodeScope extends ArrayList<Node>  {
        NodeScope parentScope;
        NodeScope() {
            this.parentScope= JmmGrammarParser.this.currentNodeScope;
            JmmGrammarParser.this.currentNodeScope= this;
        }

        boolean isRootScope() {
            return parentScope== null;
        }

        Node rootNode() {
            NodeScope ns= this;
            while (ns.parentScope!=null) {
                ns= ns.parentScope;
            }
            return ns.isEmpty()?null:
            ns.get(0);
        }

        Node peek() {
            return isEmpty()?parentScope.peek():
            get(size()-1);
        }

        Node pop() {
            return isEmpty()?parentScope.pop():
            remove(size()-1);
        }

        void poke(Node n) {
            if (isEmpty()) {
                parentScope.poke(n);
            }
            else  {
                set(size()-1, n);
            }
        }

        void close() {
            parentScope.addAll(this);
            JmmGrammarParser.this.currentNodeScope= parentScope;
        }

        int nestingLevel() {
            int result= 0;
            NodeScope parent= this;
            while (parent.parentScope!=null) {
                result++;
                parent= parent.parentScope;
            }
            return result;
        }

        public NodeScope clone() {
            NodeScope clone= (NodeScope) super.clone();
            if (parentScope!=null) {
                clone.parentScope= (NodeScope) parentScope.clone();
            }
            return clone;
        }

    }
}
