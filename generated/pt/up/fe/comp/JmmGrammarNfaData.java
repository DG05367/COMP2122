/* Generated by: JavaCC 21 Parser Generator. JmmGrammarNfaData.java */
package pt.up.fe.comp;

import static pt.up.fe.comp.JmmGrammarConstants.TokenType.*;
import java.util.Arrays;
import java.util.BitSet;
import java.util.EnumSet;
/**
 * Holder class for the data used by JmmGrammarLexer
 * to do the NFA thang
 */
class JmmGrammarNfaData implements JmmGrammarConstants {
    // The functional interface that represents 
    // the acceptance method of an NFA state
    static interface NfaFunction {
        TokenType apply(int ch, BitSet bs, EnumSet<TokenType> validTypes);
    }
    static private NfaFunction[] nfaFunctions;
    // This data holder class is never instantiated
    private JmmGrammarNfaData() {
    }

    /**
   * @param the lexical state
   * @return the table of function pointers that implement the lexical state
   */
    static final NfaFunction[] getFunctionTableMap(LexicalState lexicalState) {
        // We only have one lexical state in this case, so we return that!
        return nfaFunctions;
    }

    // Initialize the various NFA method tables
    static {
        NFA_FUNCTIONS_DEFAULT_init();
    }
    static TokenType NFA_COMPOSITE_0(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        TokenType type= null;
        if (ch== '&') {
            nextStates.set(108);
        }
        else if (ch== '/') {
            nextStates.set(53);
            nextStates.set(126);
        }
        else if (ch== 'S') {
            nextStates.set(13);
        }
        else if (ch== 'b') {
            nextStates.set(46);
        }
        else if (ch== 'c') {
            nextStates.set(124);
        }
        else if (ch== 'e') {
            nextStates.set(123);
            nextStates.set(73);
        }
        else if (ch== 'f') {
            nextStates.set(10);
        }
        else if (ch== 'i') {
            nextStates.set(27);
            nextStates.set(55);
            nextStates.set(24);
        }
        else if (ch== 'l') {
            nextStates.set(87);
        }
        else if (ch== 'm') {
            nextStates.set(79);
        }
        else if (ch== 'n') {
            nextStates.set(8);
        }
        else if (ch== 'p') {
            nextStates.set(74);
        }
        else if (ch== 'r') {
            nextStates.set(12);
        }
        else if (ch== 's') {
            nextStates.set(65);
        }
        else if (ch== 't') {
            nextStates.set(76);
            nextStates.set(19);
        }
        else if (ch== 'v') {
            nextStates.set(23);
        }
        else if (ch== 'w') {
            nextStates.set(93);
        }
        if ((ch== '$')||((ch>='A'&&ch<='Z')||((ch== '_')||(ch>='a'&&ch<='z')))) {
            nextStates.set(67);
            if (validTypes.contains(IDENTIFIER)) type= IDENTIFIER;
        }
        else if (ch== '!') {
            if (validTypes.contains(EXCL)) type= EXCL;
        }
        else if (ch== '=') {
            if (validTypes.contains(EQUAL)) type= EQUAL;
        }
        else if (ch== ']') {
            if (validTypes.contains(CLOSE_RET)) type= CLOSE_RET;
        }
        else if (ch== '[') {
            if (validTypes.contains(OPEN_RET)) type= OPEN_RET;
        }
        else if (ch== '}') {
            if (validTypes.contains(CLOSE_CHAV)) type= CLOSE_CHAV;
        }
        else if (ch== '{') {
            if (validTypes.contains(OPEN_CHAV)) type= OPEN_CHAV;
        }
        else if (ch== ',') {
            if (validTypes.contains(COMMA)) type= COMMA;
        }
        else if (ch== ';') {
            if (validTypes.contains(NEXTLINE)) type= NEXTLINE;
        }
        else if (ch== '.') {
            if (validTypes.contains(DOT)) type= DOT;
        }
        else if (ch>='0'&&ch<='9') {
            nextStates.set(32);
            if (validTypes.contains(INTEGER)) type= INTEGER;
        }
        else if (ch== ')') {
            if (validTypes.contains(CLOSE_PAREN)) type= CLOSE_PAREN;
        }
        else if (ch== '(') {
            if (validTypes.contains(OPEN_PAREN)) type= OPEN_PAREN;
        }
        else if (ch== '/') {
            if (validTypes.contains(DIVIDE)) type= DIVIDE;
        }
        else if (ch== '*') {
            if (validTypes.contains(TIMES)) type= TIMES;
        }
        else if (ch== '-') {
            if (validTypes.contains(MINUS)) type= MINUS;
        }
        else if (ch== '+') {
            if (validTypes.contains(PLUS)) type= PLUS;
        }
        else if (ch== '<') {
            if (validTypes.contains(LESS)) type= LESS;
        }
        else if (ch== '\n') {
            if (validTypes.contains(_TOKEN_4)) type= _TOKEN_4;
        }
        else if (ch== '\r') {
            if (validTypes.contains(_TOKEN_3)) type= _TOKEN_3;
        }
        else if (ch== '\t') {
            if (validTypes.contains(_TOKEN_2)) type= _TOKEN_2;
        }
        else if (ch== ' ') {
            if (validTypes.contains(_TOKEN_1)) type= _TOKEN_1;
        }
        return type;
    }

    static TokenType NFA_COMPOSITE_1(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        TokenType type= null;
        if ((ch>=0x0&&ch<='\t')||((ch== 0xb||ch== '\f')||(ch>=0xe))) {
            nextStates.set(1);
        }
        else if (ch== '\n') {
            if (validTypes.contains(_TOKEN_5)) type= _TOKEN_5;
        }
        else if (ch== '\r') {
            if (validTypes.contains(_TOKEN_5)) type= _TOKEN_5;
        }
        return type;
    }

    static TokenType NFA_COMPOSITE_2(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        TokenType type= null;
        if ((ch>=0x0&&ch<=')')||((ch>='+'&&ch<='.')||(ch>='0'))) {
            nextStates.set(4);
        }
        else if (ch== '*') {
            nextStates.set(2);
        }
        else if (ch== '/') {
            if (validTypes.contains(_TOKEN_6)) type= _TOKEN_6;
        }
        return type;
    }

    static TokenType NFA_COMPOSITE_3(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        TokenType type= null;
        if ((ch>=0x0&&ch<=')')||((ch>='+'&&ch<='.')||(ch>='0'))) {
            nextStates.set(4);
        }
        else if (ch== '*') {
            nextStates.set(2);
        }
        return type;
    }

    static TokenType NFA_COMPOSITE_4(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        TokenType type= null;
        if ((ch>=0x0&&ch<=')')||(ch>='+')) {
            nextStates.set(4);
        }
        else if (ch== '*') {
            nextStates.set(2);
        }
        return type;
    }

    static TokenType NFA_COMPOSITE_5(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        TokenType type= null;
        if (ch== '\n') {
            if (validTypes.contains(_TOKEN_5)) type= _TOKEN_5;
        }
        else if (ch== '\r') {
            if (validTypes.contains(_TOKEN_5)) type= _TOKEN_5;
        }
        return type;
    }

    static TokenType NFA_COMPOSITE_6(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        TokenType type= null;
        if ((ch>=0x0&&ch<=')')||(ch>='+')) {
            nextStates.set(6);
        }
        else if (ch== '*') {
            nextStates.set(2);
        }
        return type;
    }

    static TokenType NFA_7(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 't') {
            nextStates.set(76);
        }
        return null;
    }

    static TokenType NFA_8(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'e') {
            nextStates.set(40);
        }
        return null;
    }

    static TokenType NFA_9(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'b') {
            nextStates.set(72);
        }
        return null;
    }

    static TokenType NFA_10(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'a') {
            nextStates.set(109);
        }
        return null;
    }

    static TokenType NFA_11(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'e') {
            if (validTypes.contains(FALSE)) return FALSE;
        }
        return null;
    }

    static TokenType NFA_12(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'e') {
            nextStates.set(111);
        }
        return null;
    }

    static TokenType NFA_13(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 't') {
            nextStates.set(16);
        }
        return null;
    }

    static TokenType NFA_14(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(51);
        }
        return null;
    }

    static TokenType NFA_15(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'g') {
            nextStates.set(69);
        }
        return null;
    }

    static TokenType NFA_16(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'r') {
            nextStates.set(14);
        }
        return null;
    }

    static TokenType NFA_17(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '/') {
            if (validTypes.contains(DIVIDE)) return DIVIDE;
        }
        return null;
    }

    static TokenType NFA_18(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 's') {
            nextStates.set(102);
        }
        return null;
    }

    static TokenType NFA_19(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'r') {
            nextStates.set(21);
        }
        return null;
    }

    static TokenType NFA_20(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'a') {
            nextStates.set(42);
        }
        return null;
    }

    static TokenType NFA_21(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'u') {
            nextStates.set(44);
        }
        return null;
    }

    static TokenType NFA_22(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 't') {
            nextStates.set(60);
        }
        return null;
    }

    static TokenType NFA_23(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'o') {
            nextStates.set(121);
        }
        return null;
    }

    static TokenType NFA_24(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'f') {
            if (validTypes.contains(IF)) return IF;
        }
        return null;
    }

    static TokenType NFA_25(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'n') {
            if (validTypes.contains(BOOL)) return BOOL;
        }
        return null;
    }

    static TokenType NFA_26(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'f') {
            nextStates.set(10);
        }
        return null;
    }

    static TokenType NFA_27(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'm') {
            nextStates.set(99);
        }
        return null;
    }

    static TokenType NFA_28(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'r') {
            nextStates.set(35);
        }
        return null;
    }

    static TokenType NFA_29(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(45);
        }
        return null;
    }

    static TokenType NFA_30(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 's') {
            if (validTypes.contains(THIS)) return THIS;
        }
        return null;
    }

    static TokenType NFA_31(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'd') {
            nextStates.set(119);
        }
        return null;
    }

    static TokenType NFA_32(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch>='0'&&ch<='9') {
            nextStates.set(32);
            if (validTypes.contains(INTEGER)) return INTEGER;
        }
        return null;
    }

    static TokenType NFA_33(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '(') {
            if (validTypes.contains(OPEN_PAREN)) return OPEN_PAREN;
        }
        return null;
    }

    static TokenType NFA_34(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'w') {
            nextStates.set(93);
        }
        return null;
    }

    static TokenType NFA_35(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 't') {
            if (validTypes.contains(IMPORT)) return IMPORT;
        }
        return null;
    }

    static TokenType NFA_36(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(55);
        }
        return null;
    }

    static TokenType NFA_37(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '!') {
            if (validTypes.contains(EXCL)) return EXCL;
        }
        return null;
    }

    static TokenType NFA_38(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'd') {
            if (validTypes.contains(VOID)) return VOID;
        }
        return null;
    }

    static TokenType NFA_39(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'r') {
            nextStates.set(12);
        }
        return null;
    }

    static TokenType NFA_40(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'w') {
            if (validTypes.contains(NEW)) return NEW;
        }
        return null;
    }

    static TokenType NFA_41(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'p') {
            nextStates.set(74);
        }
        return null;
    }

    static TokenType NFA_42(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 's') {
            nextStates.set(54);
        }
        return null;
    }

    static TokenType NFA_43(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'v') {
            nextStates.set(23);
        }
        return null;
    }

    static TokenType NFA_44(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'e') {
            if (validTypes.contains(TRUE)) return TRUE;
        }
        return null;
    }

    static TokenType NFA_45(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'c') {
            if (validTypes.contains(PUBLIC)) return PUBLIC;
        }
        return null;
    }

    static TokenType NFA_46(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'o') {
            nextStates.set(47);
        }
        return null;
    }

    static TokenType NFA_47(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'o') {
            nextStates.set(64);
        }
        return null;
    }

    static TokenType NFA_48(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 't') {
            nextStates.set(112);
        }
        return null;
    }

    static TokenType NFA_49(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 't') {
            nextStates.set(19);
        }
        return null;
    }

    static TokenType NFA_50(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'c') {
            if (validTypes.contains(STATIC)) return STATIC;
        }
        return null;
    }

    static TokenType NFA_51(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'n') {
            nextStates.set(85);
        }
        return null;
    }

    static TokenType NFA_52(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'h') {
            if (validTypes.contains(COMPRIMENTO)) return COMPRIMENTO;
        }
        return null;
    }

    static TokenType NFA_53(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '*') {
            nextStates.set(6);
        }
        return null;
    }

    static TokenType NFA_54(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 's') {
            if (validTypes.contains(CLASS)) return CLASS;
        }
        return null;
    }

    static TokenType NFA_55(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'n') {
            nextStates.set(84);
        }
        return null;
    }

    static TokenType NFA_56(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 's') {
            nextStates.set(11);
        }
        return null;
    }

    static TokenType NFA_57(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'S') {
            nextStates.set(13);
        }
        return null;
    }

    static TokenType NFA_58(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '.') {
            if (validTypes.contains(DOT)) return DOT;
        }
        return null;
    }

    static TokenType NFA_59(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(75);
        }
        return null;
    }

    static TokenType NFA_60(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'e') {
            nextStates.set(117);
        }
        return null;
    }

    static TokenType NFA_61(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'l') {
            nextStates.set(87);
        }
        return null;
    }

    static TokenType NFA_62(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'e') {
            nextStates.set(123);
        }
        return null;
    }

    static TokenType NFA_63(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if ((ch== '$')||((ch>='A'&&ch<='Z')||((ch== '_')||(ch>='a'&&ch<='z')))) {
            nextStates.set(67);
            if (validTypes.contains(IDENTIFIER)) return IDENTIFIER;
        }
        return null;
    }

    static TokenType NFA_64(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'l') {
            nextStates.set(128);
        }
        return null;
    }

    static TokenType NFA_65(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 't') {
            nextStates.set(96);
        }
        return null;
    }

    static TokenType NFA_66(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== ',') {
            if (validTypes.contains(COMMA)) return COMMA;
        }
        return null;
    }

    static TokenType NFA_67(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if ((ch== '$')||((ch>='0'&&ch<='9')||((ch>='A'&&ch<='Z')||((ch== '_')||(ch>='a'&&ch<='z'))))) {
            nextStates.set(67);
            if (validTypes.contains(IDENTIFIER)) return IDENTIFIER;
        }
        return null;
    }

    static TokenType NFA_68(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '/') {
            nextStates.set(126);
        }
        return null;
    }

    static TokenType NFA_69(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 't') {
            nextStates.set(52);
        }
        return null;
    }

    static TokenType NFA_70(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '*') {
            if (validTypes.contains(TIMES)) return TIMES;
        }
        return null;
    }

    static TokenType NFA_71(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'r') {
            nextStates.set(125);
        }
        return null;
    }

    static TokenType NFA_72(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'l') {
            nextStates.set(29);
        }
        return null;
    }

    static TokenType NFA_73(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'x') {
            nextStates.set(22);
        }
        return null;
    }

    static TokenType NFA_74(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'u') {
            nextStates.set(9);
        }
        return null;
    }

    static TokenType NFA_75(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'l') {
            nextStates.set(120);
        }
        return null;
    }

    static TokenType NFA_76(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'h') {
            nextStates.set(104);
        }
        return null;
    }

    static TokenType NFA_77(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'b') {
            nextStates.set(46);
        }
        return null;
    }

    static TokenType NFA_78(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '\t') {
            if (validTypes.contains(_TOKEN_2)) return _TOKEN_2;
        }
        return null;
    }

    static TokenType NFA_79(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'a') {
            nextStates.set(83);
        }
        return null;
    }

    static TokenType NFA_80(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== ';') {
            if (validTypes.contains(NEXTLINE)) return NEXTLINE;
        }
        return null;
    }

    static TokenType NFA_81(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'e') {
            nextStates.set(73);
        }
        return null;
    }

    static TokenType NFA_82(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== ' ') {
            if (validTypes.contains(_TOKEN_1)) return _TOKEN_1;
        }
        return null;
    }

    static TokenType NFA_83(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(89);
        }
        return null;
    }

    static TokenType NFA_84(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 't') {
            if (validTypes.contains(INT)) return INT;
        }
        return null;
    }

    static TokenType NFA_85(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'g') {
            if (validTypes.contains(STRING)) return STRING;
        }
        return null;
    }

    static TokenType NFA_86(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '\r') {
            if (validTypes.contains(_TOKEN_3)) return _TOKEN_3;
        }
        return null;
    }

    static TokenType NFA_87(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'e') {
            nextStates.set(103);
        }
        return null;
    }

    static TokenType NFA_88(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '/') {
            nextStates.set(53);
        }
        return null;
    }

    static TokenType NFA_89(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'n') {
            if (validTypes.contains(MAIN)) return MAIN;
        }
        return null;
    }

    static TokenType NFA_90(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '+') {
            if (validTypes.contains(PLUS)) return PLUS;
        }
        return null;
    }

    static TokenType NFA_91(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(27);
        }
        return null;
    }

    static TokenType NFA_92(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '<') {
            if (validTypes.contains(LESS)) return LESS;
        }
        return null;
    }

    static TokenType NFA_93(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'h') {
            nextStates.set(59);
        }
        return null;
    }

    static TokenType NFA_94(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '{') {
            if (validTypes.contains(OPEN_CHAV)) return OPEN_CHAV;
        }
        return null;
    }

    static TokenType NFA_95(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '=') {
            if (validTypes.contains(EQUAL)) return EQUAL;
        }
        return null;
    }

    static TokenType NFA_96(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'a') {
            nextStates.set(48);
        }
        return null;
    }

    static TokenType NFA_97(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== ')') {
            if (validTypes.contains(CLOSE_PAREN)) return CLOSE_PAREN;
        }
        return null;
    }

    static TokenType NFA_98(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'u') {
            nextStates.set(71);
        }
        return null;
    }

    static TokenType NFA_99(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'p') {
            nextStates.set(116);
        }
        return null;
    }

    static TokenType NFA_100(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'a') {
            nextStates.set(25);
        }
        return null;
    }

    static TokenType NFA_101(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '[') {
            if (validTypes.contains(OPEN_RET)) return OPEN_RET;
        }
        return null;
    }

    static TokenType NFA_102(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'e') {
            if (validTypes.contains(ELSE)) return ELSE;
        }
        return null;
    }

    static TokenType NFA_103(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'n') {
            nextStates.set(15);
        }
        return null;
    }

    static TokenType NFA_104(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(30);
        }
        return null;
    }

    static TokenType NFA_105(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '}') {
            if (validTypes.contains(CLOSE_CHAV)) return CLOSE_CHAV;
        }
        return null;
    }

    static TokenType NFA_106(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 's') {
            nextStates.set(65);
        }
        return null;
    }

    static TokenType NFA_107(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'm') {
            nextStates.set(79);
        }
        return null;
    }

    static TokenType NFA_108(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '&') {
            if (validTypes.contains(AND)) return AND;
        }
        return null;
    }

    static TokenType NFA_109(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'l') {
            nextStates.set(56);
        }
        return null;
    }

    static TokenType NFA_110(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '&') {
            nextStates.set(108);
        }
        return null;
    }

    static TokenType NFA_111(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 't') {
            nextStates.set(98);
        }
        return null;
    }

    static TokenType NFA_112(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(50);
        }
        return null;
    }

    static TokenType NFA_113(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(24);
        }
        return null;
    }

    static TokenType NFA_114(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '-') {
            if (validTypes.contains(MINUS)) return MINUS;
        }
        return null;
    }

    static TokenType NFA_115(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'n') {
            nextStates.set(8);
        }
        return null;
    }

    static TokenType NFA_116(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'o') {
            nextStates.set(28);
        }
        return null;
    }

    static TokenType NFA_117(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'n') {
            nextStates.set(31);
        }
        return null;
    }

    static TokenType NFA_118(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '\n') {
            if (validTypes.contains(_TOKEN_4)) return _TOKEN_4;
        }
        return null;
    }

    static TokenType NFA_119(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 's') {
            if (validTypes.contains(EXTENDS)) return EXTENDS;
        }
        return null;
    }

    static TokenType NFA_120(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'e') {
            if (validTypes.contains(WHILE)) return WHILE;
        }
        return null;
    }

    static TokenType NFA_121(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(38);
        }
        return null;
    }

    static TokenType NFA_122(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== ']') {
            if (validTypes.contains(CLOSE_RET)) return CLOSE_RET;
        }
        return null;
    }

    static TokenType NFA_123(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'l') {
            nextStates.set(18);
        }
        return null;
    }

    static TokenType NFA_124(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'l') {
            nextStates.set(20);
        }
        return null;
    }

    static TokenType NFA_125(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'n') {
            if (validTypes.contains(RETORNO)) return RETORNO;
        }
        return null;
    }

    static TokenType NFA_126(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '/') {
            nextStates.set(1);
        }
        return null;
    }

    static TokenType NFA_127(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'c') {
            nextStates.set(124);
        }
        return null;
    }

    static TokenType NFA_128(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'e') {
            nextStates.set(100);
        }
        return null;
    }

    static TokenType NFA_129(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '*') {
            nextStates.set(2);
        }
        return null;
    }

    static TokenType NFA_130(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if ((ch>=0x0&&ch<=')')||(ch>='+')) {
            nextStates.set(6);
        }
        return null;
    }

    static TokenType NFA_131(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '*') {
            nextStates.set(2);
        }
        return null;
    }

    static TokenType NFA_132(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if ((ch>=0x0&&ch<=')')||(ch>='+')) {
            nextStates.set(4);
        }
        return null;
    }

    static TokenType NFA_133(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if ((ch>=0x0&&ch<='\t')||((ch== 0xb||ch== '\f')||(ch>=0xe))) {
            nextStates.set(1);
        }
        return null;
    }

    static TokenType NFA_134(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '\r') {
            if (validTypes.contains(_TOKEN_5)) return _TOKEN_5;
        }
        return null;
    }

    static TokenType NFA_135(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if ((ch>=0x0&&ch<=')')||((ch>='+'&&ch<='.')||(ch>='0'))) {
            nextStates.set(4);
        }
        return null;
    }

    static TokenType NFA_136(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '/') {
            if (validTypes.contains(_TOKEN_6)) return _TOKEN_6;
        }
        return null;
    }

    static TokenType NFA_137(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '*') {
            nextStates.set(2);
        }
        return null;
    }

    static TokenType NFA_138(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '\n') {
            if (validTypes.contains(_TOKEN_5)) return _TOKEN_5;
        }
        return null;
    }

    static private void NFA_FUNCTIONS_DEFAULT_init() {
        NfaFunction[] functions= new NfaFunction[139];
        functions[0]= JmmGrammarNfaData::NFA_COMPOSITE_0;
        functions[1]= JmmGrammarNfaData::NFA_COMPOSITE_1;
        functions[2]= JmmGrammarNfaData::NFA_COMPOSITE_2;
        functions[3]= JmmGrammarNfaData::NFA_COMPOSITE_3;
        functions[4]= JmmGrammarNfaData::NFA_COMPOSITE_4;
        functions[5]= JmmGrammarNfaData::NFA_COMPOSITE_5;
        functions[6]= JmmGrammarNfaData::NFA_COMPOSITE_6;
        functions[7]= JmmGrammarNfaData::NFA_7;
        functions[8]= JmmGrammarNfaData::NFA_8;
        functions[9]= JmmGrammarNfaData::NFA_9;
        functions[10]= JmmGrammarNfaData::NFA_10;
        functions[11]= JmmGrammarNfaData::NFA_11;
        functions[12]= JmmGrammarNfaData::NFA_12;
        functions[13]= JmmGrammarNfaData::NFA_13;
        functions[14]= JmmGrammarNfaData::NFA_14;
        functions[15]= JmmGrammarNfaData::NFA_15;
        functions[16]= JmmGrammarNfaData::NFA_16;
        functions[17]= JmmGrammarNfaData::NFA_17;
        functions[18]= JmmGrammarNfaData::NFA_18;
        functions[19]= JmmGrammarNfaData::NFA_19;
        functions[20]= JmmGrammarNfaData::NFA_20;
        functions[21]= JmmGrammarNfaData::NFA_21;
        functions[22]= JmmGrammarNfaData::NFA_22;
        functions[23]= JmmGrammarNfaData::NFA_23;
        functions[24]= JmmGrammarNfaData::NFA_24;
        functions[25]= JmmGrammarNfaData::NFA_25;
        functions[26]= JmmGrammarNfaData::NFA_26;
        functions[27]= JmmGrammarNfaData::NFA_27;
        functions[28]= JmmGrammarNfaData::NFA_28;
        functions[29]= JmmGrammarNfaData::NFA_29;
        functions[30]= JmmGrammarNfaData::NFA_30;
        functions[31]= JmmGrammarNfaData::NFA_31;
        functions[32]= JmmGrammarNfaData::NFA_32;
        functions[33]= JmmGrammarNfaData::NFA_33;
        functions[34]= JmmGrammarNfaData::NFA_34;
        functions[35]= JmmGrammarNfaData::NFA_35;
        functions[36]= JmmGrammarNfaData::NFA_36;
        functions[37]= JmmGrammarNfaData::NFA_37;
        functions[38]= JmmGrammarNfaData::NFA_38;
        functions[39]= JmmGrammarNfaData::NFA_39;
        functions[40]= JmmGrammarNfaData::NFA_40;
        functions[41]= JmmGrammarNfaData::NFA_41;
        functions[42]= JmmGrammarNfaData::NFA_42;
        functions[43]= JmmGrammarNfaData::NFA_43;
        functions[44]= JmmGrammarNfaData::NFA_44;
        functions[45]= JmmGrammarNfaData::NFA_45;
        functions[46]= JmmGrammarNfaData::NFA_46;
        functions[47]= JmmGrammarNfaData::NFA_47;
        functions[48]= JmmGrammarNfaData::NFA_48;
        functions[49]= JmmGrammarNfaData::NFA_49;
        functions[50]= JmmGrammarNfaData::NFA_50;
        functions[51]= JmmGrammarNfaData::NFA_51;
        functions[52]= JmmGrammarNfaData::NFA_52;
        functions[53]= JmmGrammarNfaData::NFA_53;
        functions[54]= JmmGrammarNfaData::NFA_54;
        functions[55]= JmmGrammarNfaData::NFA_55;
        functions[56]= JmmGrammarNfaData::NFA_56;
        functions[57]= JmmGrammarNfaData::NFA_57;
        functions[58]= JmmGrammarNfaData::NFA_58;
        functions[59]= JmmGrammarNfaData::NFA_59;
        functions[60]= JmmGrammarNfaData::NFA_60;
        functions[61]= JmmGrammarNfaData::NFA_61;
        functions[62]= JmmGrammarNfaData::NFA_62;
        functions[63]= JmmGrammarNfaData::NFA_63;
        functions[64]= JmmGrammarNfaData::NFA_64;
        functions[65]= JmmGrammarNfaData::NFA_65;
        functions[66]= JmmGrammarNfaData::NFA_66;
        functions[67]= JmmGrammarNfaData::NFA_67;
        functions[68]= JmmGrammarNfaData::NFA_68;
        functions[69]= JmmGrammarNfaData::NFA_69;
        functions[70]= JmmGrammarNfaData::NFA_70;
        functions[71]= JmmGrammarNfaData::NFA_71;
        functions[72]= JmmGrammarNfaData::NFA_72;
        functions[73]= JmmGrammarNfaData::NFA_73;
        functions[74]= JmmGrammarNfaData::NFA_74;
        functions[75]= JmmGrammarNfaData::NFA_75;
        functions[76]= JmmGrammarNfaData::NFA_76;
        functions[77]= JmmGrammarNfaData::NFA_77;
        functions[78]= JmmGrammarNfaData::NFA_78;
        functions[79]= JmmGrammarNfaData::NFA_79;
        functions[80]= JmmGrammarNfaData::NFA_80;
        functions[81]= JmmGrammarNfaData::NFA_81;
        functions[82]= JmmGrammarNfaData::NFA_82;
        functions[83]= JmmGrammarNfaData::NFA_83;
        functions[84]= JmmGrammarNfaData::NFA_84;
        functions[85]= JmmGrammarNfaData::NFA_85;
        functions[86]= JmmGrammarNfaData::NFA_86;
        functions[87]= JmmGrammarNfaData::NFA_87;
        functions[88]= JmmGrammarNfaData::NFA_88;
        functions[89]= JmmGrammarNfaData::NFA_89;
        functions[90]= JmmGrammarNfaData::NFA_90;
        functions[91]= JmmGrammarNfaData::NFA_91;
        functions[92]= JmmGrammarNfaData::NFA_92;
        functions[93]= JmmGrammarNfaData::NFA_93;
        functions[94]= JmmGrammarNfaData::NFA_94;
        functions[95]= JmmGrammarNfaData::NFA_95;
        functions[96]= JmmGrammarNfaData::NFA_96;
        functions[97]= JmmGrammarNfaData::NFA_97;
        functions[98]= JmmGrammarNfaData::NFA_98;
        functions[99]= JmmGrammarNfaData::NFA_99;
        functions[100]= JmmGrammarNfaData::NFA_100;
        functions[101]= JmmGrammarNfaData::NFA_101;
        functions[102]= JmmGrammarNfaData::NFA_102;
        functions[103]= JmmGrammarNfaData::NFA_103;
        functions[104]= JmmGrammarNfaData::NFA_104;
        functions[105]= JmmGrammarNfaData::NFA_105;
        functions[106]= JmmGrammarNfaData::NFA_106;
        functions[107]= JmmGrammarNfaData::NFA_107;
        functions[108]= JmmGrammarNfaData::NFA_108;
        functions[109]= JmmGrammarNfaData::NFA_109;
        functions[110]= JmmGrammarNfaData::NFA_110;
        functions[111]= JmmGrammarNfaData::NFA_111;
        functions[112]= JmmGrammarNfaData::NFA_112;
        functions[113]= JmmGrammarNfaData::NFA_113;
        functions[114]= JmmGrammarNfaData::NFA_114;
        functions[115]= JmmGrammarNfaData::NFA_115;
        functions[116]= JmmGrammarNfaData::NFA_116;
        functions[117]= JmmGrammarNfaData::NFA_117;
        functions[118]= JmmGrammarNfaData::NFA_118;
        functions[119]= JmmGrammarNfaData::NFA_119;
        functions[120]= JmmGrammarNfaData::NFA_120;
        functions[121]= JmmGrammarNfaData::NFA_121;
        functions[122]= JmmGrammarNfaData::NFA_122;
        functions[123]= JmmGrammarNfaData::NFA_123;
        functions[124]= JmmGrammarNfaData::NFA_124;
        functions[125]= JmmGrammarNfaData::NFA_125;
        functions[126]= JmmGrammarNfaData::NFA_126;
        functions[127]= JmmGrammarNfaData::NFA_127;
        functions[128]= JmmGrammarNfaData::NFA_128;
        functions[129]= JmmGrammarNfaData::NFA_129;
        functions[130]= JmmGrammarNfaData::NFA_130;
        functions[131]= JmmGrammarNfaData::NFA_131;
        functions[132]= JmmGrammarNfaData::NFA_132;
        functions[133]= JmmGrammarNfaData::NFA_133;
        functions[134]= JmmGrammarNfaData::NFA_134;
        functions[135]= JmmGrammarNfaData::NFA_135;
        functions[136]= JmmGrammarNfaData::NFA_136;
        functions[137]= JmmGrammarNfaData::NFA_137;
        functions[138]= JmmGrammarNfaData::NFA_138;
        nfaFunctions= functions;
    }

}
